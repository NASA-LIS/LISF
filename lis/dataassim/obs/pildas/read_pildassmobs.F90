!-----------------------BEGIN NOTICE -- DO NOT EDIT-----------------------
! NASA Goddard Space Flight Center
! Land Information System Framework (LISF)
! Version 7.3
!
! Copyright (c) 2020 United States Government as represented by the
! Administrator of the National Aeronautics and Space Administration.
! All Rights Reserved.
!-------------------------END NOTICE -- DO NOT EDIT-----------------------
#include "LIS_misc.h"
#include "LIS_NetCDF_inc.h"

!BOP
! !ROUTINE: read_pildassmobs
! \label{read_pildassmobs}
!
! !REVISION HISTORY:
!  21Jun2006: Sujay Kumar; Initial Specification
!  9Sep2016: Mahdi Navari; Modified for pildas 
!
! !INTERFACE: 
subroutine read_pildassmobs(n, k, OBS_State, OBS_Pert_state) 
! !USES: 
#if ( defined USE_NETCDF3 || defined USE_NETCDF4 )
  use netcdf
#endif
  use ESMF
  use LIS_mpiMod
  use LIS_historyMod
  use LIS_coreMod
  use LIS_dataAssimMod
  use LIS_logMod
  use LIS_pluginIndices
  use LIS_DAobservationsMod
  use pildassmobs_module

  implicit none
! !ARGUMENTS: 
  integer, intent(in) :: n 
  integer, intent(in) :: k
  type(ESMF_State)    :: OBS_State
  type(ESMF_State)    :: OBS_Pert_State
!
! !DESCRIPTION:
!  
!  reads the synthetic soil moisture observations 
!  produced from a LIS control run, applies bias correction, 
!  and quality control. The processed data is packaged 
!  into an ESMF State for later use within the DA algorithm. 
!  
!  The arguments are: 
!  \begin{description}
!  \item[n]                index of the nest
!  \item[k]                index of the data assimilation instance
!  \item[OBS\_State]       observations state
!  \item[OBS\_Pert\_State] observations perturbation state
!  \end{description}
!
!EOP
  real, parameter     :: minssdev = 0.01
  real, parameter     :: maxssdev = 0.11
  real,  parameter    :: MAX_SM_VALUE=0.45, MIN_SM_VALUE=0.0001
  type(ESMF_Field)    :: smfield , pertfield

  real,    pointer    :: obsl(:)
  integer             :: gid(LIS_rc%obs_ngrid(k))
  integer             :: assimflag(LIS_rc%obs_ngrid(k))
  real                :: obs_unsc(LIS_rc%obs_ngrid(k))
  character*100       :: smobsdir
  logical             :: data_update
  logical             :: file_exists
  character*80        :: fname
  integer             :: fnd
  integer             :: ftn
  logical             :: readflag
  integer             :: status
  logical             :: data_upd_flag(LIS_npes)
  logical             :: data_upd_flag_local
  logical             :: data_upd
  real                :: sm_current(LIS_rc%obs_lnc(k),LIS_rc%obs_lnr(k))
  integer             :: t,c,r,i,j,p,jj
  ! MN
  real                :: smobs(LIS_rc%obs_lnc(k)*LIS_rc%obs_lnr(k))
  real                :: SFMC_OBS(LIS_rc%lnc(n),LIS_rc%lnr(n))
  integer             :: nid
  integer             :: smid
  integer             :: ios
  real                :: lon
  real                :: lhour
  integer             :: grid_index
  real                :: timenow
  logical             :: alarmCheck
  real, allocatable      :: ssdev(:)



  call ESMF_AttributeGet(OBS_State,"Data Directory",&
       smobsdir, rc=status)
  call LIS_verify(status, 'ESMF_AttributeGet failed in read_PILDASsm')
  call ESMF_AttributeGet(OBS_State,"Data Update Status",&
       data_update, rc=status)
  call LIS_verify(status, 'ESMF_AttributeGet failed in read_PILDASsm')

  data_upd = .false.
  obs_unsc = LIS_rc%udef
!  smobs = LIS_rc%udef
!-------------------------------------------------------------------------
!   Read the data at 12:00 UTC  
!-------------------------------------------------------------------------

  timenow = float(LIS_rc%hr)*3600 + 60*LIS_rc%mn + LIS_rc%ss
! MN: NOTE: Pildas obs set to be at 12:00 UTC
  alarmcheck = (timenow.eq.43200)

  if(alarmCheck.or.pildas_sm_struc(n)%startMode) then
     pildas_sm_struc(n)%startMode = .false.
     
 ! MN
 ! Note: pildas synthetic observation filename convention generated by 
 ! Matlab code "NLDASsfsm_to_synthnOBS_O003_MN.m" is as following
 ! PILDAS-1_synobs_O002V001_20010101_120000.nc4
 ! Note that O002 is start by capital letter "O" follows by 002
     call pildassm_filename(fname,smobsdir,&
          LIS_rc%yr, LIS_rc%mo, LIS_rc%da, LIS_rc%hr, LIS_rc%mn)
     
     inquire(file=fname,exist=file_exists)

     if(file_exists) then 
        readflag = .true. 
     else 
        readflag = .false.
     endif
  
     if (readflag) then 
        write(LIS_logunit,*)  '[INFO] Reading syn data ',fname

        call read_PILDAS_data(n,k,fname,smobs)

        pildas_sm_struc(n)%smobs = LIS_rc%udef

        do r=1,LIS_rc%obs_lnr(k)
           do c=1,LIS_rc%obs_lnc(k)
              grid_index = LIS_obs_domain(n,k)%gindex(c,r)
              if(grid_index.ne.-1) then
                 if(smobs(c+(r-1)*LIS_rc%obs_lnc(k)).gt.0) then
                    pildas_sm_struc(n)%smobs(c,r) = &
                         smobs(c+(r-1)*LIS_rc%obs_lnc(k))
                    
                    !lon = LIS_obs_domain(n,k)%lon(c+(r-1)*LIS_rc%obs_lnc(k))
                    !MN : not sure if we need this 
                    !lhour = 12.0
                    !call LIS_localtime2gmt (gmt,lon,lhour,zone)
                    !pildas_sm_struc(n)%smtime(c,r) = gmt
                 endif
              endif
           enddo
        enddo

     end if

     call ESMF_StateGet(OBS_State,"Observation01",smfield,&
          rc=status)
     call LIS_verify(status, 'Error: StateGet Observation01')
     ! MN: pointer to connect OBS_State with obsl
     call ESMF_FieldGet(smfield,localDE=0,farrayPtr=obsl,rc=status)
     call LIS_verify(status, 'Error: FieldGet')
     
     !  ---------------MN : Not Sure we need this ---------------------
     fnd = 0
     sm_current = LIS_rc%udef
     
     
     do r=1,LIS_rc%obs_lnr(k)
        do c=1,LIS_rc%obs_lnc(k)
           if(LIS_obs_domain(n,k)%gindex(c,r).ne.-1) then
              grid_index = c+(r-1)*LIS_rc%obs_lnc(k)
              
              !           dt = (LIS_rc%gmt - pildas_sm_struc(n)%smtime(c,r))*3600.0
              !           if(dt.ge.0.and.dt.lt.LIS_rc%ts) then
              sm_current(c,r) = &
                   pildas_sm_struc(n)%smobs(c,r)
              if(LIS_obs_domain(n,k)%gindex(c,r).ne.-1) then
                 obs_unsc(LIS_obs_domain(n,k)%gindex(c,r)) = &
                      sm_current(c,r)
              endif
              if(sm_current(c,r).ne.LIS_rc%udef) then
                 fnd = 1
              endif
              !endif
           endif
        enddo
     enddo
     !--------------------------------------------------------------
     
  
     !-------------------------------------------------------------------------
     !  Transform data to the LSM climatology using a CDF-scaling approach
     !-------------------------------------------------------------------------     
     
     if(LIS_rc%dascaloption(k).eq."CDF matching".and.fnd.eq.1) then       
     !if(LIS_rc%dascaloption(k).ne."none".and.fnd.ne. 0 ) then  
        ! MN: perform CDF matching              
        call LIS_rescale_with_CDF_matching(    &
             n,k,                              & 
             pildas_sm_struc(n)%nbins,         & 
             pildas_sm_struc(n)%ntimes,        & 
             MAX_SM_VALUE,                     & 
             MIN_SM_VALUE,                     & 
             pildas_sm_struc(n)%model_xrange,  &
             pildas_sm_struc(n)%obs_xrange,    &
             pildas_sm_struc(n)%model_cdf,     &
             pildas_sm_struc(n)%obs_cdf,       &
             sm_current)
     endif
     
     obsl = LIS_rc%udef
     ! MN: save the scaled data into obsl (which goes to OBS_State since we used pointer)
     do r =1,LIS_rc%obs_lnr(k)
        do c =1,LIS_rc%obs_lnc(k)
           if (LIS_obs_domain(n,k)%gindex(c,r) .ne. -1)then
              obsl(LIS_obs_domain(n,k)%gindex(c,r))=sm_current(c,r)
           end if
        end do
     end do
     
     !-------------------------------------------------------------------------
     !  Apply LSM-based QC and screening of observations
     !-------------------------------------------------------------------------     
     
     call lsmdaqcobsstate(trim(LIS_rc%lsm)//"+"&
          //trim(LIS_pildassmobsId)//char(0),n, k, OBS_state)
     
     call LIS_checkForValidObs(n, k,obsl,fnd,sm_current)
     
     if(fnd.eq.0) then 
        data_upd_flag_local = .false.
     else
        data_upd_flag_local = .true.
     endif
     
#if (defined SPMD)
     call MPI_ALLGATHER(data_upd_flag_local,1, &
          MPI_LOGICAL, data_upd_flag(:),&
          1, MPI_LOGICAL, LIS_mpi_comm, status)
#endif
     data_upd = .false.
     do p=1,LIS_npes
        data_upd = data_upd.or.data_upd_flag(p)
     enddo
     
     if(data_upd) then 
        do t=1,LIS_rc%obs_ngrid(k)
           gid(t) = t
           if(obsl(t).ne.-9999.0) then 
              assimflag(t) = 1
              !fnd = 1 !MN
           else
              assimflag(t) = 0
           endif
        enddo
        
        
        call ESMF_AttributeSet(OBS_State,"Data Update Status",&
             .true., rc=status)
        call LIS_verify(status,&
             'ESMF_AttributeSet: Data Update Status failed in read_pildassmobs')
        
        if(LIS_rc%obs_ngrid(k).gt.0) then 
           call ESMF_AttributeSet(smfield,"Grid Number",&
                gid,itemCount=LIS_rc%obs_ngrid(k),rc=status)
           call LIS_verify(status,& 
                'ESMF_AttributeSet: Grid Number failed in read_pildassnobs')
           
           call ESMF_AttributeSet(smfield,"Assimilation Flag",&
                assimflag,itemCount=LIS_rc%obs_ngrid(k),rc=status)
           call LIS_verify(status,&
                'ESMF_AttributeSet: Assimilation Flag failed in read_pildassmobs')
           
           call ESMF_AttributeSet(smfield, "Unscaled Obs",&
                obs_unsc, itemCount=LIS_rc%obs_ngrid(k), rc=status)
           call LIS_verify(status, 'Error in setting Unscaled Obs attribute')      
        endif
        
        if(pildas_sm_struc(n)%useSsdevScal.eq.1.and.&
             pildas_sm_struc(n)%ntimes.gt.1) then 
           
           call ESMF_StateGet(OBS_Pert_State,"Observation01",pertfield,&
                rc=status)
           call LIS_verify(status, 'Error: StateGet Observation01')
           
           allocate(ssdev(LIS_rc%obs_ngrid(k)))
           ssdev = pildas_sm_struc(n)%ssdev_inp
           if(pildas_sm_struc(n)%ntimes.eq.1) then 
              jj = 1
           else
              jj = LIS_rc%mo
           endif
           
           do t=1,LIS_rc%obs_ngrid(k)
              if(pildas_sm_struc(n)%obs_sigma(t,jj).gt.0) then 
                 ssdev(t) = ssdev(t)*pildas_sm_struc(n)%model_sigma(t,jj)/&
                      pildas_sm_struc(n)%obs_sigma(t,jj)
                 if(ssdev(t).gt.maxssdev) ssdev(t) = maxssdev
                 if(ssdev(t).lt.minssdev) then 
                    ssdev(t) = minssdev
                 endif
              endif
           enddo
           
           if(LIS_rc%obs_ngrid(k).gt.0) then 
              call ESMF_AttributeSet(pertField,"Standard Deviation",&
                   ssdev,itemCount=LIS_rc%obs_ngrid(k),rc=status)
              call LIS_verify(status)
           endif
           deallocate(ssdev)
        endif
        
     else
        call ESMF_AttributeSet(OBS_State,"Data Update Status",&
             .false., rc=status)
        call LIS_verify(status,&
             'ESMF_AttributeSet: Data Update Status failed in read_pildassmobs')
     endif
     write(LIS_logunit,*)  '[INFO] Finished reading syn data ',fname
  else
     call ESMF_AttributeSet(OBS_State,"Data Update Status",&
          .false., rc=status)
     call LIS_verify(status)
     return
  end if
  
end subroutine read_pildassmobs





!BOP
! 
! !ROUTINE: read_PILDAS_data
! \label{read_PILDAS_data}
!
! !INTERFACE:
subroutine read_PILDAS_data(n, k, fname, smobs_ip)
  ! 
  ! !USES:   
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
  use netcdf
#endif
  use LIS_coreMod,  only : LIS_rc, LIS_domain
  use LIS_logMod,   only : LIS_verify
  use pildassmobs_module, only : pildas_sm_struc
  
  implicit none
  !
  ! !INPUT PARAMETERS: 
  ! 
  integer                       :: n
  integer                       :: k
  character (len=*)             :: fname
  real                          :: smobs_ip(LIS_rc%obs_lnc(k)*LIS_rc%obs_lnr(k))
  
  
  ! !OUTPUT PARAMETERS:
  !
  ! !DESCRIPTION: 
  !  This subroutine reads the PILDAS syn. sm. obs. NETCDF file and applies the basic 
  !  data quality flags to filter the data. (0<sm<0.45)  
  ! 
  !  The arguments are: 
  !  \begin{description}
  !  \item[n]            index of the nest
  !  \item[fname]        name of the PILDAS file
  !  \item[smobs\_ip]    soil moisture data processed to the LIS domain
  ! \end{description}
  !
  ! !FILES USED:
  !
  ! !REVISION HISTORY: 
  ! 
  !EOP
  real         :: SFMC_OBS(pildas_sm_struc(n)%pil_nc,pildas_sm_struc(n)%pil_nr)
  !  integer      :: flag(pildas_sm_struc(n)%pil_nc,pildas_sm_struc(n)%pil_nr)
  
  real         :: sm_combined(pildas_sm_struc(n)%pil_nc,pildas_sm_struc(n)%pil_nr)
  real         :: sm_data(pildas_sm_struc(n)%pil_nc*pildas_sm_struc(n)%pil_nr)
  logical*1    :: sm_data_b(pildas_sm_struc(n)%pil_nc*pildas_sm_struc(n)%pil_nr)
  logical*1    :: smobs_b_ip(LIS_rc%obs_lnc(k)*LIS_rc%obs_lnr(k))
  
  integer      :: c,r,i,j
  real         :: rlat,rlon,ri,rj
  integer      :: nid
  integer      :: smid !, flagid
  integer      :: ios
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
  
  ! MN: Read obs data from Netcdf file 
  ios = nf90_open(path=trim(fname),mode=NF90_NOWRITE,ncid=nid)
  call LIS_verify(ios,'Error opening file '//trim(fname))
  
  ios = nf90_inq_varid(nid, 'SFMC_OBS',smid)
  call LIS_verify(ios, 'Error nf90_inq_varid: SFMC_OBS')
  
  
  !MN get values
  ios = nf90_get_var(nid, smid, SFMC_OBS)
  call LIS_verify(ios, 'Error nf90_get_var: SFMC_OBS')
  
  ios = nf90_close(ncid=nid)
  call LIS_verify(ios,'Error closing file '//trim(fname))
  
  do r=1, pildas_sm_struc(n)%pil_nr
     do c=1, pildas_sm_struc(n)%pil_nc
        
        !MN: we don't need to flip the martix because netcdf file has been generated by  
        !MATLAB and matlab flip the file. 
        
        if(SFMC_OBS(c,r).gt. 0.45 .or. SFMC_OBS(c,r).le. 0.0) then
           !sm_combined(c,pildas_sm_struc(n)%pil_nr-r+1) = LIS_rc%udef
           sm_combined(c,r) = LIS_rc%udef
        else
           !sm_combined(c,pildas_sm_struc(n)%pil_nr-r+1) = SFMC_OBS(c,r)
           sm_combined(c,r) = SFMC_OBS(c,r)
        endif
     enddo
  enddo
  
  do r=1, pildas_sm_struc(n)%pil_nr
     do c=1, pildas_sm_struc(n)%pil_nc
        sm_data(c+(r-1)*pildas_sm_struc(n)%pil_nc) = sm_combined(c,r)
        if(sm_combined(c,r).ne.LIS_rc%udef) then
           sm_data_b(c+(r-1)*pildas_sm_struc(n)%pil_nc) = .true.
        else
           sm_data_b(c+(r-1)*pildas_sm_struc(n)%pil_nc) = .false.
        endif
        if(sm_combined(c,r).gt.0.5) then
           sm_combined(c,r) = LIS_rc%udef
           sm_data_b(c+(r-1)*pildas_sm_struc(n)%pil_nc) = .false.
        endif
     enddo
  enddo

  !--------------------------------------------------------------------------
  ! Interpolate to the DA observation space
  !-------------------------------------------------------------------------- 
  call neighbor_interp(LIS_rc%obs_gridDesc(k,:),&
       sm_data_b, sm_data, smobs_b_ip, smobs_ip, &
       pildas_sm_struc(n)%pil_nc*pildas_sm_struc(n)%pil_nr, &
       LIS_rc%obs_lnc(k)*LIS_rc%obs_lnr(k), &
       pildas_sm_struc(n)%rlat, pildas_sm_struc(n)%rlon, &
       pildas_sm_struc(n)%n11,LIS_rc%udef, ios)
  
  !open(100,file='test.bin',form='unformatted')
  !write(100) smobs_ip
  !close(100)
  !stop

#endif
  
end subroutine read_pildas_data




!BOP
!
! !ROUTINE: pildassm_filename
! \label{pildassm_filename}
!
! !INTERFACE: 
subroutine pildassm_filename(fname, ndir, yr, mo,da,hr,mn)
  
  implicit none
  ! !ARGUMENTS: 
  character*80      :: fname
  integer           :: yr, mo, da, hr,mn
  character (len=*) :: ndir
  ! 
  ! !DESCRIPTION: 
  !  This routine creates the filename containing the synthetic soil 
  !  moisture data
  !
  !EOP
  
  character (len=4) :: fyr
  character (len=2) :: fmo,fda,fhr,fmn
  
  write(unit=fyr, fmt='(i4.4)') yr
  write(unit=fmo, fmt='(i2.2)') mo
  write(unit=fda, fmt='(i2.2)') da
  write(unit=fhr, fmt='(i2.2)') hr
  write(unit=fmn, fmt='(i2.2)') mn  
  
  !name = trim(ndir)//'/SOILM_'//trim(fyr)//trim(fmo)//trim(fda)//trim(fhr)//&
  !     trim(fmn)//'.bin'
  fname = trim(ndir)//'/Y'//trim(fyr)//'/M'//trim(fmo)// &
       '/PILDAS-1_synobs_O002V001_'// &
       trim(fyr)//trim(fmo)//trim(fda)//'_'//trim(fhr)// &
       trim(fmn)//'00.nc4'
end subroutine pildassm_filename

