!-----------------------BEGIN NOTICE -- DO NOT EDIT-----------------------
! NASA Goddard Space Flight Center Land Information System (LIS) v7.2
!
! Copyright (c) 2015 United States Government as represented by the
! Administrator of the National Aeronautics and Space Administration.
! All Rights Reserved.
!-------------------------END NOTICE -- DO NOT EDIT-----------------------
#include "LIS_misc.h"
! Macros for tracing - Requires ESMF 7_1_0+
#ifdef ESMF_TRACE
#define TRACE_ENTER(region) call ESMF_TraceRegionEnter(region)
#define TRACE_EXIT(region) call ESMF_TraceRegionExit(region)
#else
#define TRACE_ENTER(region)
#define TRACE_EXIT(region)
#endif
module LIS_dataAssimMod
!BOP
!
! !MODULE: LIS_dataAssimMod
! 
! !DESCRIPTION: 
!   The module controls the management of  different
!   data assimilation implementations. 
!   
!  \subsubsection{Overview}
!   This module defines some of the interface plugins for the 
!   incorporation of different data assimilation implementations.
!   There are three main levels of abstractions identified in a
!   data assimilation implementation: 
!   \begin{itemize}
!   \item{Data Assimilation Algorithm: various methods such as 
!     direct insertion, extended kalman filter, ensemble kalman
!     filter, etc.}
!   \item{Observations/Variable being assimilated: this abstraction
!     identifies the source of variables, and the translation of 
!     observations to model state variables. }
!   \item{Land surface model: the model used in the assimilation 
!     implementation.}
!   \item{Pertubation techniques: methods to perturb the forcing and 
!    model prognostic variables}
!   \end{itemize}
!
!   A complete implementation would require the interaction between 
!   the specific instances of the components listed above. This module
!   includes methods to invoke some of the above. 
! 
! !REVISION HISTORY: 
!  27 Feb 2005    Sujay Kumar; Initial Specification
!   7 Sep 2017    Mahdi Navari; set a condition to deal the skewness of the both model and obs CDF 
!   1 Apr 2019    Yonghwan Kwon; include an option to read soil moisture CDF information for each month separately
! 
! !USES: 
  use ESMF
  use LIS_coreMod
  use LIS_logMod
  use LIS_historyMod
  use LIS_DAobservationsMod

#if(defined USE_NETCDF3 || defined USE_NETCDF4)
  use netcdf
#endif

  implicit none
  
  PRIVATE
!-----------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:
!-----------------------------------------------------------------------------
  public :: LIS_dataassim_init      !initialize data assimilation routines
  public :: LIS_dataassim_run       !invoke data assimilation algorithms
  public :: LIS_dataassim_output   !invoke data assimilation output
  public :: LIS_dataassim_finalize  !cleanup allocated structures
  public :: LIS_rescale_with_CDF_matching !rescale with CDF matching
  public :: LIS_rescale_with_linear_scaling
  public :: LIS_getCDFattributes
  public :: LIS_readCDFdata !read the CDF files generated by LDT
  public :: LIS_readMeanSigmaData
  public :: LIS_forwardEstimate_with_ANN
!EOP 
  public :: LIS_DA_struc

  type, public :: LIS_DA_dec
     integer                    :: NPPB
     integer                    :: NHSIZE
     character*100              :: ANN_activ_function
     character*50, allocatable  :: ANN_inp_units(:)
     real, allocatable          :: ANN_out_minr(:)
     real, allocatable          :: ANN_out_maxr(:)
     real, allocatable          :: ANN_inp_minr(:,:)
     real, allocatable          :: ANN_inp_maxr(:,:)
     real, allocatable          :: ANN_wi(:,:,:)
     real, allocatable          :: ANN_wo(:,:)
  end type LIS_DA_dec
  
  type(LIS_DA_dec), allocatable :: LIS_DA_struc(:)

!BOP
!
! !ROUTINE: LIS_readCDFdata
! \label{LIS_readCDFdata}
!
! !INTERFACE:
  interface LIS_readCDFdata
! !PRIVATE MEMBER FUNCTIONS:
     module procedure read_CDFdata_all
     module procedure read_CDFdata_month
!
! !DESCRIPTION:
!  This interface proivides routines for reading the input CDF file 
!  (generated by LDT in NETCDF forman).
!
!EOP
  end interface

!BOP
!
! !ROUTINE: LIS_readMeanSigmaData
! \label{LIS_readMeanSigmaData}
!
! !INTERFACE:
  interface LIS_readMeanSigmaData
! !PRIVATE MEMBER FUNCTIONS:
     module procedure read_MeanSigmaData_all
     module procedure read_MeanSigmaData_month
!
! !DESCRIPTION:
!  This interface proivides routines for reading the input CDF file
!  (generated by LDT in NETCDF forman).
!
!EOP
  end interface

contains

!BOP
! !ROUTINE: LIS_dataassim_init
! \label{LIS_dataassim_init}
!
! !INTERFACE: 
  subroutine LIS_dataassim_init
! 
! !USES: 

! !DESCRIPTION: 
! 
! The routine performs the initializations required for data
! assimilation. The registries that define the instances of 
! data assimilation algorithms, observations, and perturbation
! methods are invoked, followed by the creation of required
! data structures. 
!
! The calling sequence is: 
! \begin{description}
!  \item[LIS\_dataassim\_plugin](\ref{LIS_dataassim_plugin}) \newline
!    sets up function table registries for implemented 
!    data assimilation algorithms
!  \item[LIS\_biasEstimation\_plugin](\ref{LIS_biasEstimation_plugin}) \newline
!    sets up function table registries for implemented 
!    bias estimation algorithms. 
!  \item[dataassiminit](\ref{dataassiminit}) \newline
!    invokes the generic method in the registry to initialize the 
!    data assimilation algorithm- structures
!  \item[dataassimsetup](\ref{dataassimsetup}) \newline
!    invokes the generic method in the registry to set up the 
!    data assimilation algorithm- structures
!  \item[biasestimationsetup](\ref{biasestimationsetup}) \newline
!    invokes the generic method in the registry to set up the 
!    bias estimation algorithm structures. 
! \end{description}
!EOP
    implicit none

    integer              :: max_index
    logical              :: name_found
    character*20         :: alglist(10)
    integer,    allocatable  :: insts(:)    
    integer              :: n,i,j,k
    integer              :: status

    real,            allocatable  :: minr_out(:)
    real,            allocatable  :: maxr_out(:)
    real,            allocatable  :: minr_inp(:,:)
    real,            allocatable  :: maxr_inp(:,:)
    real,            allocatable  :: wi(:,:,:)
    real,            allocatable  :: wo(:,:)
    
    integer               :: iloc
    integer               :: nid, ngridID, nppbId, nhsizeId
    integer               :: maxr_outId, minr_outId,wiId,woId
    integer               :: maxr_inpId, minr_inpId
    integer               :: ngrid_file
    real,   allocatable   :: maxr_out_file(:),minr_out_file(:)
    real,   allocatable   :: maxr_inp_file(:,:),minr_inp_file(:,:)
    real,   allocatable   :: wo_file(:,:),wi_file(:,:,:)
    logical               :: check_flag
    character*1000        :: allunits

    TRACE_ENTER("DA_init")
    max_index = -1
    do i=1,LIS_rc%ndas
       if(max_index.eq.-1.and.LIS_rc%daalg(i).ne."none") then 
          max_index = 1
          alglist(max_index) = LIS_rc%daalg(i)
       else
          name_found = .false. 
          do k=1,max_index
             if(LIS_rc%daalg(i).ne."none".and.&
                  LIS_rc%daalg(i).eq.alglist(k)) then
                name_found = .true. 
             endif
          enddo
          if(.not.name_found.and.max_index.ne.-1) then 
             max_index = max_index + 1
             alglist(max_index) = LIS_rc%daalg(i)
          endif
       endif
    enddo

    if(max_index.gt.0) then 
       do i=1,max_index
!Call this only once for all instances of the algorithm
          call dataassiminit(trim(alglist(i))//char(0))
       enddo
    endif
    do i=1,LIS_rc%ndas
       call dataassimsetup(trim(LIS_rc%daalg(i))//char(0),i)
    enddo

    max_index = -1
    do i=1,LIS_rc%ndas
       if(max_index.eq.-1.and.LIS_rc%biasalg(i).ne."none") then 
          max_index = 1
          alglist(max_index) = LIS_rc%biasalg(i)
       else
          name_found = .false. 
          do k=1,max_index
             if(LIS_rc%biasalg(i).ne."none".and.&
                  LIS_rc%biasalg(i).eq.alglist(k)) then
                name_found = .true. 
             endif
          enddo
          if(.not.name_found.and.max_index.ne.-1) then 
             max_index = max_index + 1
             alglist(max_index) = LIS_rc%biasalg(i)
          endif
       endif
    enddo

    if(max_index.gt.0) then 
       do i=1,max_index
!Call this only once for all instances of the algorithm
          call biasestimationinit(trim(alglist(i))//char(0))
       enddo
    endif

    do i=1,LIS_rc%ndas
       if(LIS_rc%biasalg(i).ne."none") then 
          call biasestimationsetup(trim(LIS_rc%biasalg(i))//char(0),i)
       endif
    enddo
    
! Inputs if a trained ANN is used as a forward model 
    if(LIS_rc%ndas.gt.0) then 

       allocate(LIS_DA_struc(LIS_rc%nnest))
       allocate(LIS_rc%useANNinDA(LIS_rc%nnest))
       allocate(LIS_rc%ANNdaFile(LIS_rc%nnest))

       check_flag = .false. 

       call ESMF_ConfigFindLabel(LIS_config,&
            "Data assimilation use a trained forward model:",&
            rc=status)
       do n=1,LIS_rc%nnest
          call ESMF_ConfigGetAttribute(LIS_config,LIS_rc%useANNinDA(n), &
               rc=status)
          call LIS_verify(status, &
               "Data assimilation use a trained forward model: not defined")
          if(LIS_rc%useANNinDA(n).eq.1) then 
             check_flag = .true. 
          endif
       enddo
       
       call ESMF_ConfigFindLabel(LIS_config,&
            "Data assimilation trained forward model output file:",&
            rc=status)
       do n=1,LIS_rc%nnest
          call ESMF_ConfigGetAttribute(LIS_config,LIS_rc%ANNdaFile(n), &
               rc=status)
          call LIS_verify(status, &
               "Data assimilation trained forward model output file: not defined")
       enddo

       if(check_flag) then 
          do n=1,LIS_rc%nnest
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
             write(LIS_logunit,*) '[INFO] Reading ANN output file ',trim(LIS_rc%ANNdaFile(n))
             call LIS_verify(nf90_open(path=trim(LIS_rc%ANNdaFile(n)),mode=NF90_NOWRITE,&
                  ncid=nid),'failed to open file '//trim(LIS_rc%ANNdaFile(n)))
             
             call LIS_verify(nf90_inq_dimid(nid,"ngrid",ngridId), &
                  'nf90_inq_dimid failed for ngrid')
             call LIS_verify(nf90_inq_dimid(nid,"nppb",nppbId), &
                  'nf90_inq_dimid failed for nppb')
             call LIS_verify(nf90_inq_dimid(nid,"nhsize",nhsizeId), &
                  'nf90_inq_dimid failed for nhsize')
             
             call LIS_verify(nf90_inquire_dimension(nid,ngridId, len=ngrid_file),&
                  'nf90_inquire_dimension failed for ngrid')
             call LIS_verify(nf90_inquire_dimension(nid,nppbId, &
                  len=LIS_DA_struc(n)%nppb),&
                  'nf90_inquire_dimension failed for nppb')
             call LIS_verify(nf90_inquire_dimension(nid,nhsizeId,&
                  len=LIS_DA_struc(n)%nhsize),&
                  'nf90_inquire_dimension failed for nhsize')
             
!             if(ngrid_file.ne.LIS_rc%glbngrid_red(n)) then 
!                write(LIS_logunit,*) '[ERR] The number of grid points specified in the file '//&
!                     trim(LIS_rc%ANNdaFile(n))
!                write(LIS_logunit,*) '[ERR] (',ngrid_file, &
!                     ') is different from the number of grid points in the LIS domain ('
!                write(LIS_logunit,*) '[ERR] ',LIS_rc%glbngrid_red(n)
!                call LIS_endrun()
!             endif
             
             allocate(minr_out_file(ngrid_file))
             allocate(maxr_out_file(ngrid_file))
             allocate(minr_inp_file(ngrid_file,LIS_DA_struc(n)%nppb))
             allocate(maxr_inp_file(ngrid_file,LIS_DA_struc(n)%nppb))
             allocate(wo_file(ngrid_file, LIS_DA_struc(n)%nhsize))
             allocate(wi_file(ngrid_file, LIS_DA_struc(n)%nppb, &
                  LIS_DA_struc(n)%nhsize))
             
             allocate(LIS_DA_struc(n)%ANN_out_minr(LIS_rc%ngrid(n)))
             allocate(LIS_DA_struc(n)%ANN_out_maxr(LIS_rc%ngrid(n)))
             allocate(LIS_DA_struc(n)%ANN_inp_minr(LIS_rc%ngrid(n),&
                  LIS_DA_struc(n)%nppb))
             allocate(LIS_DA_struc(n)%ANN_inp_maxr(LIS_rc%ngrid(n),&
                  LIS_DA_struc(n)%nppb))
             allocate(LIS_DA_struc(n)%ANN_wi(LIS_rc%ngrid(n), &
                  LIS_DA_struc(n)%nppb, &
                  LIS_DA_struc(n)%nhsize))
             allocate(LIS_DA_struc(n)%ANN_wo(LIS_rc%ngrid(n), &
                  LIS_DA_struc(n)%nhsize))
             
             call LIS_verify(nf90_get_att(nid, NF90_GLOBAL, &
                  'Activation_function', &
                  LIS_DA_struc(n)%ANN_activ_function), &
                  'Error in nf90_get_att: Activation_function')
             call LIS_verify(nf90_get_att(nid, NF90_GLOBAL, &
                  'Input_variable_units', &
                  allunits), &
                  'Error in nf90_get_att: Input_variable_units')
             
             allocate(LIS_DA_struc(n)%ANN_inp_units(LIS_DA_struc(n)%nppb-1))
             LIS_DA_struc(n)%ANN_inp_units = ""

             do i=1,LIS_DA_struc(n)%nppb-2
                iloc=index(allunits,",")
                LIS_DA_struc(n)%ANN_inp_units(i) = allunits(1:iloc-1)
                allunits = allunits(iloc+1:len(allunits))
             enddo

             LIS_DA_struc(n)%ANN_inp_units(LIS_DA_struc(n)%nppb-1) = & 
                  trim(allunits)

             call LIS_verify(nf90_inq_varid(nid,'MINRANGE_OUTPUTS',minr_outId),&
                  'nf90_inq_varid failed for MINRANGE_OUTPUTS')
             call LIS_verify(nf90_inq_varid(nid,'MAXRANGE_OUTPUTS',maxr_outId),&
                  'nf90_inq_varid failed for MAXRANGE_OUTPUTS')
             call LIS_verify(nf90_inq_varid(nid,'MINRANGE_INPUTS',minr_inpId),&
                  'nf90_inq_varid failed for MINRANGE_INPUTS')
             call LIS_verify(nf90_inq_varid(nid,'MAXRANGE_INPUTS',maxr_inpId),&
                  'nf90_inq_varid failed for MAXRANGE_INPUTS')
             call LIS_verify(nf90_inq_varid(nid,'WI',wiId),&
                  'nf90_inq_varid failed for WI')
             call LIS_verify(nf90_inq_varid(nid,'WO',woId),&
                  'nf90_inq_varid failed for WO')
             
             call LIS_verify(nf90_get_var(nid,minr_inpId,minr_inp_file),&
                  'nf90_get_var failed for MINRANGE_INPUTS')
             call LIS_verify(nf90_get_var(nid,maxr_inpId,maxr_inp_file),&
                  'nf90_get_var failed for MAXRANGE_INPUTS')
             call LIS_verify(nf90_get_var(nid,minr_outId,minr_out_file),&
                  'nf90_get_var failed for MINRANGE_OUTPUTS')
             call LIS_verify(nf90_get_var(nid,minr_outId,maxr_out_file),&
                  'nf90_get_var failed for MAXRANGE_OUTPUTS')
             call LIS_verify(nf90_get_var(nid,wiId,wi_file),&
                  'nf90_get_var failed for WI')
             call LIS_verify(nf90_get_var(nid,woId,wo_file),&
                  'nf90_get_var failed for WO')
             
             
             if(LIS_rc%ngrid(n).gt.0) then 

                do j=1,LIS_DA_struc(n)%nppb
                   call LIS_convertVarToLocalSpace(n,minr_inp_file(:,j), &
                        LIS_DA_struc(n)%ANN_inp_minr(:,j))
                   call LIS_convertVarToLocalSpace(n,maxr_inp_file(:,j), &
                        LIS_DA_struc(n)%ANN_inp_maxr(:,j))
                enddo

                call LIS_convertVarToLocalSpace(n,minr_out_file(:), &
                     LIS_DA_struc(n)%ANN_out_minr(:))
                call LIS_convertVarToLocalSpace(n,maxr_out_file(:), &
                     LIS_DA_struc(n)%ANN_out_maxr(:))
                
                do i=1,LIS_DA_struc(n)%nhsize
                   do j=1,LIS_DA_struc(n)%nppb
                      call LIS_convertVarToLocalSpace(n,wi_file(:,j,i), &
                           LIS_DA_struc(n)%ANN_wi(:,j,i))
                   enddo
                   call LIS_convertVarToLocalSpace(n,wo_file(:,i),&
                        LIS_DA_struc(n)%ANN_wo(:,i))
                enddo
             endif

             deallocate(minr_inp_file)
             deallocate(maxr_inp_file)
             
             deallocate(minr_out_file)
             deallocate(maxr_out_file)

             deallocate(wo_file)
             deallocate(wi_file)
             
             call LIS_verify(nf90_close(nid),&
                  'failed to close file '//trim(LIS_rc%ANNdaFile(n)))
             write(LIS_logunit,*) '[INFO] Successfully read ANN output file ',&
                  trim(LIS_rc%ANNdaFile(n))
          enddo
       endif
    endif

    do i=1,LIS_rc%ndas
       call lsmdainit(trim(LIS_rc%lsm)//"+"//&
            trim(LIS_rc%daset(i))//char(0),i)
    enddo

#endif
  TRACE_EXIT("DA_init")
  end subroutine LIS_dataassim_init


!BOP
! !ROUTINE: LIS_dataassim_run
! \label{LIS_dataassim_run}
!
! !INTERFACE: 
  subroutine LIS_dataassim_run(n)
! 
! !USES: 

! !DESCRIPTION:
!  The routine initiates the call to the specific assimilation
!  algorithm.   
! 
! The calling sequence is: 
! \begin{description}
!  \item[computeIncrements](\ref{computeIncrements}) \newline
!   computes the increments from the analysis
!  \item[applybiascorrection](\ref{applybiascorrection}) \newline
!   applies the bias correction increments
!  \item[applyIncrements](\ref{applyIncrements}) \newline
!   applies the increments from the analysis
! \end{description}
! 
!EOP
    implicit none
    
    integer :: n
    integer :: j
    
    TRACE_ENTER("DA_run")
!old
!    do j=1,LIS_rc%ndas
!       if(LIS_rc%daalg(j).gt.0) then 
!          call computeIncrements(LIS_rc%daalg(j), n,j)
!          if(LIS_rc%biasalg(j).gt.0) then 
!             call applyBiasCorrection(&
!                  LIS_rc%biasalg(j), n, j)
!          endif
!          call applyIncrements(LIS_rc%daalg(j), n, j)
!       endif
!    enddo

    do j=1,LIS_rc%ndas
       if(LIS_rc%daalg(j).ne."none") then 

          if(LIS_rc%biasalg(j).ne."none") then
             call computeBiasCorrection(trim(LIS_rc%biasalg(j))//char(0), n, j)
          endif

          call computeIncrements(trim(LIS_rc%daalg(j))//char(0), n,j)

          if(LIS_rc%biasalg(j).ne."none") then 
             call applyBiasCorrection(trim(LIS_rc%biasalg(j))//char(0), n, j)
          endif

          call applyIncrements(trim(LIS_rc%daalg(j))//char(0), n, j)

       endif
    enddo
    TRACE_EXIT("DA_run")

  end subroutine LIS_dataassim_run


!BOP
! !ROUTINE: LIS_dataassim_output
! \label{LIS_dataassim_output}
! 
! !INTERFACE: 
  subroutine LIS_dataassim_output(n)
! 
! !USES:

!
! !DESCRIPTION: 
!  This routine issues the invocation to write data 
!  assimilation specific output
!
! The calling sequence is: 
! \begin{description}
!  \item[daoutput](\ref{daoutput}) \newline
!    invokes the generic method in the registry to write
!    data assimilation specific output
! \end{description}
!EOP
    implicit none

    integer, intent(IN)  :: n 

    integer              :: j 

    TRACE_ENTER("DA_out")
!write bias restart
    do j=1,LIS_rc%ndas
       if(LIS_rc%daalg(j).ne."none") then 
          if(LIS_rc%biasalg(j).ne."none") then
             call writebiasrestart(trim(LIS_rc%biasalg(j))//char(0),n,j)
          endif
       endif
    enddo

    do j=1,LIS_rc%ndas
       if(LIS_rc%daalg(j).ne."none") then 
          call daoutput(trim(LIS_rc%daalg(j))//char(0),n,j)
       endif
    enddo
    TRACE_EXIT("DA_out")
    
  end subroutine LIS_dataassim_output

!BOP
! !ROUTINE: LIS_dataassim_finalize
! \label{LIS_dataassim_finalize}
! 
! !INTERFACE: 
  subroutine LIS_dataassim_finalize
! 
! !USES:

!
! !DESCRIPTION: 
!  This routine issues the invocation to deallocate and cleanup
!  any allocated data structures in the specific instance of the 
!  data assimilation implementations. 
!
! The calling sequence is: 
! \begin{description}
!  \item[dafinalize](\ref{dafinalize}) \newline
!    invokes the generic method in the registry to cleanup 
!    the allocated structures for the data assimilation algorithm
! \end{description}
!EOP
    implicit none

!DISABLE for now
!    if(LIS_rc%daalg.gt.0) then 
!       call dafinalize(LIS_rc%daalg)
!    endif

  end subroutine LIS_dataassim_finalize


!BOP
! 
! !ROUTINE: LIS_rescale_with_CDF_matching
! \label{LIS_rescale_with_CDF_matching}
!
! !INTERFACE:
  subroutine LIS_rescale_with_CDF_matching(&
       n,             & 
       k,             & 
       nbins,         & 
       ntimes,        & 
       max_obs_value, & 
       min_obs_value, & 
       model_xrange,  & 
       obs_xrange,    &       
       model_cdf,     &
       obs_cdf,       &
       obs_value) 

       
    implicit none
! 
! !ARGUMENTS: 
    integer             :: n 
    integer             :: k
    integer             :: nbins
    integer             :: ntimes
    real                :: max_obs_value
    real                :: min_obs_value
    real                :: model_xrange(LIS_rc%obs_ngrid(k),ntimes, nbins)
    real                :: obs_xrange(LIS_rc%obs_ngrid(k),ntimes, nbins)
    real                :: model_cdf(LIS_rc%obs_ngrid(k),ntimes, nbins)
    real                :: obs_cdf(LIS_rc%obs_ngrid(k),ntimes, nbins)
    real                :: obs_value(LIS_rc%obs_lnc(k),LIS_rc%obs_lnr(k))
!
! !DESCRIPTION: 
! 
!   This routine rescales the input observation data to the model's
!   climatology so that the cumulative distribution functions (CDFs)
!   of the observations and the model match (for each grid point). 
! 
!   Ref: Reichle and Koster, 2004, Bias reduction in short records of 
!   satellite soil moisture, Geophys. Res. Lett. 31, L19501, 
!   doi:10.1029/2004GL020938. 
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]               index of the nest
!  \item[nbins]           number of bins used to compute the model and obs CDFs
!  \item[max\_obs\_value] maximum allowable value of observation
!  \item[min\_obs\_value] minimum allowable value of observation
!  \item[model\_xrange]   x-axis values corresponding to the model CDF
!  \item[obs\_xrange]     x-axis values corresponding to the obs CDF
!  \item[model\_cdf]      y-axis (CDF) values corresponding to the model CDF
!  \item[obs\_cdf]        y-axis (CDF) values corresponding to the obs CDF
!  \item[obs\_value]      observation value to be rescaled. 
! \end{description}
!EOP

    real                :: model_delta(LIS_rc%obs_ngrid(k))
    real                :: obs_delta(LIS_rc%obs_ngrid(k))

    integer             :: t,i,kk
    integer             :: binval
    integer             :: col,row
    real                :: cdf_obsval
    real                :: obs_tmp, obs_in
    integer, dimension (1)      :: index_25 , index_75
    real                :: Lb_xrange, Ub_xrange, iqr_obs, iqr_model

    TRACE_ENTER("DA_rescaleCDF")          
    if(ntimes.gt.1) then 
       kk = LIS_rc%mo
    else
       kk = 1
    endif
    do t=1,LIS_rc%obs_ngrid(k)
       model_delta(t) = model_xrange(t,kk,2)-model_xrange(t,kk,1)
       obs_delta(t)   = obs_xrange(t,kk,2)-obs_xrange(t,kk,1)
    enddo
    do t=1,LIS_rc%obs_ngrid(k)
       
        col = LIS_obs_domain(n,k)%col(t)
        row = LIS_obs_domain(n,k)%row(t)
! MN : Replaced the dynamic range with the interquartile range   
 
!SVK dynamic range of obs is too small. 
!        if((obs_xrange(t,kk,nbins)-obs_xrange(t,kk,1)).lt.&
!           (max_obs_value-min_obs_value)*0.25) then 
!           obs_delta(t) = 0
!        endif

        index_25 = minloc(abs(obs_cdf(t,kk,:) - 0.25))
        index_75 = minloc(abs(obs_cdf(t,kk,:) - 0.75))
        Lb_xrange = obs_xrange(t,kk,index_25(1))
        Ub_xrange = obs_xrange(t,kk,index_75(1))
        iqr_obs = Ub_xrange - Lb_xrange

        index_25 = minloc(abs(model_cdf(t,kk,:) - 0.25))
        index_75 = minloc(abs(model_cdf(t,kk,:) - 0.75))
        Lb_xrange = model_xrange(t,kk,index_25(1))
        Ub_xrange = model_xrange(t,kk,index_75(1))
        iqr_model = Ub_xrange - Lb_xrange
     
! MN: 
! In a normal distribution 50% of data will fall between +/- 0.67448 sigma (1.134896 sigma)
! and 99.7% of data are between the +/-3 sigma (6 sigma) By dividing these two values we
! get 1.134896 / 6 = 0.189. That means IQR is about the 0.19 of the 
! x-range (~ dynamic range of the variable).
! We can say if IQR is less than 0.05 of the x-range then CDF is too 
! steep and it is better to ignore that for CDF matching.  
! NOTE: more tests are needed to determine the best threshold
        if( iqr_obs .lt. 0.05 * (obs_xrange(t,kk,nbins)-obs_xrange(t,kk,1)) .or. &
            iqr_model .lt. 0.05 * (model_xrange(t,kk,nbins)-model_xrange(t,kk,1)) ) then 
           obs_delta(t) = 0
        endif

        if(obs_value(col,row).ne.-9999.0) then 
           obs_in = obs_value(col,row)
           if(obs_delta(t).gt.0) then 
              binval = nint((obs_value(col,row)-obs_xrange(t,kk,1))/&
                   obs_delta(t))+1
              if(binval.gt.nbins) binval = nbins
              if(binval.le.0) binval = 1
              cdf_obsval = obs_cdf(t,kk,binval)
              if(cdf_obsval.gt.1.0) cdf_obsval = 1.0
              i=1
              do while((model_cdf(t,kk,i).lt.cdf_obsval).and.&
                   (i.le.nbins))
                 i = i+1
                 if(i.gt.nbins) exit
              enddo
              if(i.gt.nbins) i = i-1
              obs_tmp = model_xrange(t,kk,i)
              
              if(obs_tmp.gt.max_obs_value) then 
!                 obs_tmp = max_obs_value
                 obs_tmp = LIS_rc%udef
              endif
              
              if(obs_tmp.le.min_obs_value) then 
!                 obs_tmp = obs_value(col,row)
                 obs_tmp = LIS_rc%udef
              endif
              obs_value(col,row) = obs_tmp
           else
              obs_value(col,row) = LIS_rc%udef
           endif
           if(obs_value(col,row).le.min_obs_value.and.&
                obs_value(col,row).ne.-9999.0) then 
              write(LIS_logunit,*) '[ERR] Problem in CDF scaling of observations in the DA instance ',k
              write(LIS_logunit,*) '[ERR] ',col,row,obs_value(col,row), obs_in
              call LIS_endrun()
           endif
        else
           obs_value(col,row) = LIS_rc%udef
        endif
     enddo
     TRACE_EXIT("DA_rescaleCDF")
   end subroutine LIS_rescale_with_CDF_matching


!BOP
! 
! !ROUTINE: LIS_rescale_with_linear_scaling
! \label{LIS_rescale_with_linear_scaling}
!
! !INTERFACE:
  subroutine LIS_rescale_with_linear_scaling(&
       n,             & 
       k,             & 
       nbins,         & 
       ntimes,        & 
       obs_xrange,    &       
       obs_cdf,       &
       obs_value) 

       
    implicit none
! 
! !ARGUMENTS: 
    integer             :: n 
    integer             :: k
    integer             :: nbins
    integer             :: ntimes
    real                :: max_obs_value
    real                :: min_obs_value
    real                :: obs_xrange(LIS_rc%obs_ngrid(k),ntimes, nbins)
    real                :: obs_cdf(LIS_rc%obs_ngrid(k),ntimes, nbins)
    real                :: obs_value(LIS_rc%obs_lnc(k),LIS_rc%obs_lnr(k))
!
! !DESCRIPTION: 
! 
!   This routine rescales the input observation data 

!  The arguments are: 
!  \begin{description}
!  \item[n]               index of the nest
!  \item[nbins]           number of bins used to compute the model and obs CDFs
!  \item[max\_obs\_value] maximum allowable value of observation
!  \item[min\_obs\_value] minimum allowable value of observation
!  \item[model\_xrange]   x-axis values corresponding to the model CDF
!  \item[obs\_xrange]     x-axis values corresponding to the obs CDF
!  \item[model\_cdf]      y-axis (CDF) values corresponding to the model CDF
!  \item[obs\_cdf]        y-axis (CDF) values corresponding to the obs CDF
!  \item[obs\_value]      observation value to be rescaled. 
! \end{description}
!EOP

    integer             :: t,i,kk
    integer             :: binval
    integer             :: col,row
    real                :: cdf_obsval
    real                :: obs_tmp

    TRACE_ENTER("DA_rescaleLin")
    if(ntimes.gt.1) then 
       kk = LIS_rc%mo
    else
       kk = 1
    endif
    do t=1,LIS_rc%obs_ngrid(k)
       
       col = LIS_obs_domain(n,k)%col(t)
       row = LIS_obs_domain(n,k)%row(t)
       
       if(obs_value(col,row).ne.-9999.0) then 
          
          obs_tmp = (obs_value(col,row) - obs_xrange(t,kk,1))/&
               (obs_xrange(t,kk,nbins) - obs_xrange(t,kk,1))
          
          obs_value(col,row) = obs_tmp
       else
          obs_value(col,row) = LIS_rc%udef
       endif
    enddo
    TRACE_EXIT("DA_rescaleLin")
  end subroutine LIS_rescale_with_linear_scaling

!BOP
! !ROUTINE: LIS_getCDFattributes
! \label{LIS_getCDFattributes}
!
! !INTERFACE: 
   subroutine LIS_getCDFattributes(k,filename, ntimes, ngrid)
     
     implicit none
! !ARGUMENTS:      
     integer                         :: k
     character(len=*), intent(in)    :: filename
     integer                         :: ntimes
     integer                         :: ngrid
! 
! !DESCRIPTION: 
!  This routine reads the temporal resolution of CDF attribute from the 
!  CDF file
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]             index of the nest
!  \item[ntimes]        temporal resolution of the CDFs
! \end{description}
!EOP

     integer                  :: nid, gid

     TRACE_ENTER("DA_getCDFatt")
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
     call LIS_verify(nf90_open(path=trim(filename),mode=NF90_NOWRITE,&
          ncid=nid),'failed to open file '//trim(filename))

     call LIS_verify(nf90_inq_dimid(nid, 'ngrid',gId), &
          'Error nf90_inq_dimid: ngrid')
     
     call LIS_verify(nf90_inquire_dimension(nid, gId, len=ngrid), &
          'Error nf90_inquire_dimension:ngrid')

!     if(ngrid.ne.LIS_rc%obs_glbngrid_red(k)) then 
!        write(LIS_logunit,*) '[ERR] The observation grid in the CDF file '
!        write(LIS_logunit,*) '[ERR] does not match the LIS observation grid'
!        call LIS_endrun()
!     else
!        ngrid = LIS_rc%obs_ngrid(k)
!     endif

     call LIS_verify(nf90_get_att(nid, NF90_GLOBAL, &
          'temporal_resolution_CDF', &
          ntimes), &
          'Error in nf90_get_att: temporal_resolution_CDF')

     call LIS_verify(nf90_close(nid))
#endif
     TRACE_EXIT("DA_getCDFatt")

   end subroutine LIS_getCDFattributes


!BOP
! !ROUTINE: read_CDFdata_all   
! \label{read_CDFdata_all}
!
! !INTERFACE: 
   subroutine read_CDFdata_all(n, k, nbins, ntimes, ngrid, &
        filename, varname, xrange, cdf)
     
     implicit none
! !ARGUMENTS:      
     integer,   intent(in)    :: n
     integer,   intent(in)    :: k
     integer,   intent(in)    :: nbins
     integer,   intent(in)    :: ntimes
     integer,   intent(in)    :: ngrid
     character(len=*)         :: filename
     character(len=*)         :: varname
     real                     :: xrange(ngrid,ntimes, nbins)
     real                     :: cdf(ngrid,ntimes, nbins)

! 
! !DESCRIPTION: 
!  This routine reads the input CDF file (generated by LDT in NETCDF format)
!  The xrange values and the corresponding CDFs are read for each grid point. 
!  Both these fields are expected to be in the 1-d grid vector dimension. 
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]             index of the nest
!  \item[nbins]         number of bins used to compute the model and obs CDFs
!  \item[filename]      name of the CDF file
!  \item[varname]       name of the variable being extracted.
!  \item[xrange]        x-axis values corresponding to the CDF
!  \item[cdf]           y-axis (CDF) values corresponding to the CDF
! \end{description}
!EOP
     integer                  :: j,kk
     integer                  :: ngridId, nbinsId, nlevsId
     integer                  :: ngrid_file, nbins_file, nlevs_file
     integer                  :: xid, cdfid
     real, allocatable        :: xrange_file(:,:,:)
     real, allocatable        :: cdf_file(:,:,:)
     integer                  :: nid
      
     TRACE_ENTER("DA_readCDF")
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
     write(LIS_logunit,*) '[INFO] Reading CDF file ',trim(filename)
     if(ngrid.gt.0) then 
        call LIS_verify(nf90_open(path=trim(filename),mode=NF90_NOWRITE,&
             ncid=nid),'failed to open file '//trim(filename))
        
        call LIS_verify(nf90_inq_dimid(nid,"ngrid",ngridId), &
             'nf90_inq_dimid failed for ngrid')
        call LIS_verify(nf90_inq_dimid(nid,"nbins",nbinsId), &
             'nf90_inq_dimid failed for nbins')
        call LIS_verify(nf90_inq_dimid(nid,trim(varname)//"_levels",nlevsId), &
             'nf90_inq_dimid failed for '//trim(varname)//"_levels")
        
        call LIS_verify(nf90_inquire_dimension(nid,ngridId, len=ngrid_file),&
             'nf90_inquire_dimension failed for ngrid')
        call LIS_verify(nf90_inquire_dimension(nid,nbinsId, len=nbins_file),&
             'nf90_inquire_dimension failed for nbins')
        call LIS_verify(nf90_inquire_dimension(nid,nlevsId, len=nlevs_file),&
             'nf90_inquire_dimension failed for nbins')
        
        if(nbins.ne.nbins_file) then 
           write(LIS_logunit,*) '[ERR] The number of bins specified in the file '//&
                trim(filename)
           write(LIS_logunit,*) '[ERR] (',nbins_file, &
                ') is different from the number of bins specified'
           write(LIS_logunit,*) '[ERR] in the lis.config file (',nbins,')'
           call LIS_endrun()
        endif
        
        allocate(xrange_file(ngrid_file,nlevs_file, nbins))
        allocate(cdf_file(ngrid_file,nlevs_file, nbins))

        do j=1,ntimes
           call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_xrange',xid),&
                'nf90_inq_varid failed for for '//trim(varname)//'_xrange')
           call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_CDF',cdfid),&
                'nf90_inq_varid failed for '//trim(varname)//'_CDF')
           
           call LIS_verify(nf90_get_var(nid,xid,xrange_file, &
                start=(/1,j,1,1/), count=(/ngrid_file,1,nlevs_file,nbins/)),&
                'nf90_get_var failed for '//trim(varname)//'_xrange')
           call LIS_verify(nf90_get_var(nid,cdfid,cdf_file,&
                start=(/1,j,1,1/), count=(/ngrid_file,1,nlevs_file,nbins/)),&
                'nf90_get_var failed for '//trim(varname)//'_CDF')
        
           if(ngrid.gt.0) then 
              do kk=1,nbins
                 call LIS_convertObsVarToLocalSpace(n,k,xrange_file(:,1,kk), &
                      xrange(:,j,kk))
                 call LIS_convertObsVarToLocalSpace(n,k,cdf_file(:,1,kk), &
                      cdf(:,j,kk))
              enddo
           endif

        enddo

!        xrange = xrange_file
!        cdf = cdf_file

        deallocate(xrange_file)
        deallocate(cdf_file)

        call LIS_verify(nf90_close(nid),&
             'failed to close file '//trim(filename))
        write(LIS_logunit,*) '[INFO] Successfully read CDF file ',trim(filename)
     endif
#endif
     TRACE_EXIT("DA_readCDF")
   end subroutine read_CDFdata_all

!BOP
! !ROUTINE: read_CDFdata_month   
! \label{read_CDFdata_month}
!
! !INTERFACE: 
   subroutine read_CDFdata_month(n, k, nbins, ntimes, ngrid, &
        filename, varname, xrange, cdf, imonth)

     implicit none
! !ARGUMENTS:      
     integer,   intent(in)    :: n
     integer,   intent(in)    :: k
     integer,   intent(in)    :: nbins
     integer,   intent(in)    :: ntimes
     integer,   intent(in)    :: ngrid
     integer,   intent(in)    :: imonth
     character(len=*)         :: filename
     character(len=*)         :: varname
     real                     :: xrange(ngrid,1, nbins)
     real                     :: cdf(ngrid,1, nbins)

! 
! !DESCRIPTION: 
!  This routine reads the input CDF file (generated by LDT in NETCDF format)
!  The xrange values and the corresponding CDFs are read for each grid point. 
!  Both these fields are expected to be in the 1-d grid vector dimension. 
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]             index of the nest
!  \item[nbins]         number of bins used to compute the model and obs CDFs
!  \item[filename]      name of the CDF file
!  \item[varname]       name of the variable being extracted.
!  \item[xrange]        x-axis values corresponding to the CDF
!  \item[cdf]           y-axis (CDF) values corresponding to the CDF
! \end{description}
!EOP
     integer                  :: kk
     integer                  :: ngridId, nbinsId, nlevsId
     integer                  :: ngrid_file, nbins_file, nlevs_file
     integer                  :: xid, cdfid
     real, allocatable        :: xrange_file(:,:,:)
     real, allocatable        :: cdf_file(:,:,:)
     integer                  :: nid

     TRACE_ENTER("DA_readCDF")
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
     write(LIS_logunit,*) '[INFO] Reading CDF file ',trim(filename)
     if(ngrid.gt.0) then
        call LIS_verify(nf90_open(path=trim(filename),mode=NF90_NOWRITE,&
             ncid=nid),'failed to open file '//trim(filename))

        call LIS_verify(nf90_inq_dimid(nid,"ngrid",ngridId), &
             'nf90_inq_dimid failed for ngrid')
        call LIS_verify(nf90_inq_dimid(nid,"nbins",nbinsId), &
             'nf90_inq_dimid failed for nbins')
        call LIS_verify(nf90_inq_dimid(nid,trim(varname)//"_levels",nlevsId), &
             'nf90_inq_dimid failed for '//trim(varname)//"_levels")

        call LIS_verify(nf90_inquire_dimension(nid,ngridId, len=ngrid_file),&
             'nf90_inquire_dimension failed for ngrid')
        call LIS_verify(nf90_inquire_dimension(nid,nbinsId, len=nbins_file),&
             'nf90_inquire_dimension failed for nbins')
        call LIS_verify(nf90_inquire_dimension(nid,nlevsId, len=nlevs_file),&
             'nf90_inquire_dimension failed for nbins')

        if(nbins.ne.nbins_file) then
           write(LIS_logunit,*) '[ERR] The number of bins specified in the file '//&
                trim(filename)
           write(LIS_logunit,*) '[ERR] (',nbins_file, &
                ') is different from the number of bins specified'
           write(LIS_logunit,*) '[ERR] in the lis.config file (',nbins,')'
           call LIS_endrun()
        endif

        allocate(xrange_file(ngrid_file,nlevs_file, nbins))
        allocate(cdf_file(ngrid_file,nlevs_file, nbins))

        call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_xrange',xid),&
             'nf90_inq_varid failed for for '//trim(varname)//'_xrange')
        call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_CDF',cdfid),&
             'nf90_inq_varid failed for '//trim(varname)//'_CDF')

        call LIS_verify(nf90_get_var(nid,xid,xrange_file, &
             start=(/1,imonth,1,1/), count=(/ngrid_file,1,nlevs_file,nbins/)),&
             'nf90_get_var failed for '//trim(varname)//'_xrange')
        call LIS_verify(nf90_get_var(nid,cdfid,cdf_file,&
             start=(/1,imonth,1,1/), count=(/ngrid_file,1,nlevs_file,nbins/)),&
             'nf90_get_var failed for '//trim(varname)//'_CDF')

        if(ngrid.gt.0) then
           do kk=1,nbins
              call LIS_convertObsVarToLocalSpace(n,k,xrange_file(:,1,kk), &
                   xrange(:,1,kk))
              call LIS_convertObsVarToLocalSpace(n,k,cdf_file(:,1,kk), &
                   cdf(:,1,kk))
           enddo
        endif
       
!        xrange = xrange_file
!        cdf = cdf_file

        deallocate(xrange_file)
        deallocate(cdf_file)

        call LIS_verify(nf90_close(nid),&
             'failed to close file '//trim(filename))
        write(LIS_logunit,*) '[INFO] Successfully read CDF file ',trim(filename)
     endif
#endif
     TRACE_EXIT("DA_readCDF")
   end subroutine read_CDFdata_month

!BOP
! !ROUTINE: read_MeanSigmaData_all 
! \label{read_MeanSigmaData_all}
!
! !INTERFACE: 
   subroutine read_MeanSigmaData_all(n, k, ntimes, ngrid, filename, varname, mu, sigma)
     
     implicit none
! !ARGUMENTS:      
     integer,   intent(in)    :: n
     integer,   intent(in)    :: k
     integer,   intent(in)    :: ntimes
     integer,   intent(in)    :: ngrid
     character(len=*)         :: filename
     character(len=*)         :: varname
     real                     :: mu(ngrid, ntimes)
     real                     :: sigma(ngrid, ntimes)
! 
! !DESCRIPTION: 
!  This routine reads the input CDF file (generated by LDT in NETCDF format)
!  and reads the mean (mu) and standard deviation (sigma) values for each
!  grid point. 
!  Both these fields are expected to be in the 1-d grid vector dimension. 
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]             index of the nest
!  \item[filename]      name of the CDF file
!  \item[varname]       name of the variable being extracted.
!  \item[mu]            mean values
!  \item[sigma]         standard deviation values
! \end{description}
!EOP
     integer                  :: j
     integer                  :: nlevsId, gId
     integer                  :: ngrid_file, nlevs_file
     integer                  :: muid, sigmaid
     real, allocatable        :: mu_file(:,:,:)
     real, allocatable        :: sigma_file(:,:,:)
     integer                  :: nid

     TRACE_ENTER("DA_readSigma")
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
     write(LIS_logunit,*) '[INFO] Reading mean and sigma from CDF file ',trim(filename)
     call LIS_verify(nf90_open(path=trim(filename),mode=NF90_NOWRITE,&
          ncid=nid),'failed to open file '//trim(filename))

     call LIS_verify(nf90_inq_dimid(nid,trim(varname)//"_levels",nlevsId), &
          'nf90_inq_dimid failed for '//trim(varname)//"_levels")

     call LIS_verify(nf90_inquire_dimension(nid,nlevsId, len=nlevs_file),&
          'nf90_inquire_dimension failed for nbins')
   
     call LIS_verify(nf90_inq_dimid(nid, 'ngrid',gId), &
          'Error nf90_inq_dimid: ngrid')
     
     call LIS_verify(nf90_inquire_dimension(nid, gId, len=ngrid_file), &
          'Error nf90_inquire_dimension:ngrid') 

     allocate(mu_file(ngrid_file,ntimes, nlevs_file))
     allocate(sigma_file(ngrid_file,ntimes, nlevs_file))

     call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_mu',muid),&
          'nf90_inq_varid failed for for '//trim(varname)//'_mu')
     call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_sigma',sigmaid),&
          'nf90_inq_varid failed for '//trim(varname)//'_sigma')
     
     call LIS_verify(nf90_get_var(nid,muid,mu_file),&
          'nf90_get_var failed for '//trim(varname)//'_mu')
     call LIS_verify(nf90_get_var(nid,sigmaid,sigma_file),&
          'nf90_get_var failed for '//trim(varname)//'_sigma')

     if(LIS_rc%obs_ngrid(k).gt.0) then 
        do j=1,ntimes
           call LIS_convertObsVarToLocalSpace(n,k,mu_file(:,j,1), mu(:,j))
           call LIS_convertObsVarToLocalSpace(n,k,sigma_file(:,j,1),sigma(:,j))
        enddo
     endif

!     mu(:,:)    = mu_file(:,:,1)
!     sigma(:,:) = sigma_file(:,:,1)

     deallocate(mu_file)
     deallocate(sigma_file)

     call LIS_verify(nf90_close(nid),&
          'failed to close file '//trim(filename))
     write(LIS_logunit,*) '[INFO] Successfully read mean and sigma from CDF file ',trim(filename)
#endif
     TRACE_EXIT("DA_readSigma")
   end subroutine read_MeanSigmaData_all

!BOP
! !ROUTINE: read_MeanSigmaData_month
! \label{read_MeanSigmaData_month}
!
! !INTERFACE:
   subroutine read_MeanSigmaData_month(n, k, ntimes, ngrid, filename, varname, mu, sigma, imonth)

     implicit none
! !ARGUMENTS:
     integer,   intent(in)    :: n
     integer,   intent(in)    :: k
     integer,   intent(in)    :: ntimes
     integer,   intent(in)    :: ngrid
     integer,   intent(in)    :: imonth
     character(len=*)         :: filename
     character(len=*)         :: varname
     real                     :: mu(ngrid, 1)
     real                     :: sigma(ngrid, 1)
!
! !DESCRIPTION:
!  This routine reads the input CDF file (generated by LDT in NETCDF format)
!  and reads the mean (mu) and standard deviation (sigma) values for each
!  grid point.
!  Both these fields are expected to be in the 1-d grid vector dimension.
!
!  The arguments are:
!  \begin{description}
!  \item[n]             index of the nest
!  \item[filename]      name of the CDF file
!  \item[varname]       name of the variable being extracted.
!  \item[mu]            mean values
!  \item[sigma]         standard deviation values
! \end{description}
!EOP

     integer                  :: nlevsId, gId
     integer                  :: ngrid_file, nlevs_file
     integer                  :: muid, sigmaid
     real, allocatable        :: mu_file(:,:,:)
     real, allocatable        :: sigma_file(:,:,:)
     integer                  :: nid

     TRACE_ENTER("DA_readSigma")
#if(defined USE_NETCDF3 || defined USE_NETCDF4)
     write(LIS_logunit,*) '[INFO] Reading mean and sigma from CDF file ',trim(filename)
     call LIS_verify(nf90_open(path=trim(filename),mode=NF90_NOWRITE,&
          ncid=nid),'failed to open file '//trim(filename))

     call LIS_verify(nf90_inq_dimid(nid,trim(varname)//"_levels",nlevsId), &
          'nf90_inq_dimid failed for '//trim(varname)//"_levels")

     call LIS_verify(nf90_inquire_dimension(nid,nlevsId, len=nlevs_file),&
          'nf90_inquire_dimension failed for nbins')

     call LIS_verify(nf90_inq_dimid(nid, 'ngrid',gId), &
          'Error nf90_inq_dimid: ngrid')

     call LIS_verify(nf90_inquire_dimension(nid, gId, len=ngrid_file), &
          'Error nf90_inquire_dimension:ngrid')

     allocate(mu_file(ngrid_file, 1, nlevs_file))
     allocate(sigma_file(ngrid_file, 1, nlevs_file))

     call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_mu',muid),&
          'nf90_inq_varid failed for for '//trim(varname)//'_mu')
     call LIS_verify(nf90_inq_varid(nid,trim(varname)//'_sigma',sigmaid),&
          'nf90_inq_varid failed for '//trim(varname)//'_sigma')

     call LIS_verify(nf90_get_var(nid,muid,mu_file,&
          start=(/1,imonth,1/), count=(/ngrid_file,1,nlevs_file/)),&
          'nf90_get_var failed for '//trim(varname)//'_mu')
     call LIS_verify(nf90_get_var(nid,sigmaid,sigma_file,&
          start=(/1,imonth,1/), count=(/ngrid_file,1,nlevs_file/)),&
          'nf90_get_var failed for '//trim(varname)//'_sigma')

     if(LIS_rc%obs_ngrid(k).gt.0) then
           call LIS_convertObsVarToLocalSpace(n,k,mu_file(:,1,1), mu(:,1))
           call LIS_convertObsVarToLocalSpace(n,k,sigma_file(:,1,1),sigma(:,1))
     endif

!     mu(:,:)    = mu_file(:,:,1)
!     sigma(:,:) = sigma_file(:,:,1)

     deallocate(mu_file)
     deallocate(sigma_file)

     call LIS_verify(nf90_close(nid),&
          'failed to close file '//trim(filename))
     write(LIS_logunit,*) '[INFO] Successfully read mean and sigma from CDF file ',trim(filename)
#endif
     TRACE_EXIT("DA_readSigma")
   end subroutine read_MeanSigmaData_month

!BOP 
! 
! !ROUTINE: LIS_forwardEstimate_with_ANN
! \label{LIS_forwardEstimate_with_ANN}
!
! !INTERFACE: 
   subroutine LIS_forwardEstimate_with_ANN(n, t, ANN_inputs, ANN_units, &
        out_value)
! !ARGUMENTS: 
     integer,           intent(in) :: n 
     integer,           intent(in) :: t
     real                          :: ANN_inputs(LIS_DA_struc(n)%nppb-1)
     character(len=*)              :: ANN_units(LIS_DA_struc(n)%nppb-1)
     real                          :: out_value
!
! !DESCRIPTION: 
!  This routine employs the weights from a trained ANN and provides
!  the outputs for a given set of inputs
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]             index of the nest
!  \item[t]             grid space index of the current grid cell
!  \item[ANN\_inputs]   array of inputs 
!  \item[ANN\_units]    array of input units
!  \item[out\_value]     array of outputs
! \end{description}
!EOP
     integer                       :: i
     real                          :: hval(LIS_DA_struc(n)%nhsize)
     real                          :: outpredl
     real                          :: maxr_out,minr_out
     real                          :: inputs_tp(LIS_DA_struc(n)%nppb)
     real                          :: wi(LIS_DA_struc(n)%nppb,LIS_DA_struc(n)%nhsize)
     real                          :: wo(LIS_DA_struc(n)%nhsize)
     
     TRACE_ENTER("DA_fwdEst")
     do i=1,LIS_DA_struc(n)%nppb-1
        if(ANN_units(i).ne.LIS_DA_struc(n)%ANN_inp_units(i)) then 
           write(LIS_logunit,*) '[ERR] Units mismatch between ANN trained inputs and the interface inputs'
           write(LIS_logunit,*) '[ERR] ANN trained unit ',i, trim(LIS_DA_struc(n)%ANN_inp_units(i))
           write(LIS_logunit,*) '[ERR] Interface input unit ',i, trim(ANN_units(i))
           call LIS_endrun()
           
        endif
     enddo

     inputs_tp(1:LIS_DA_struc(n)%nppb-1) = ANN_inputs(:)
     call scaleANNinputs(n,t,inputs_tp)

     maxr_out = LIS_DA_struc(n)%ANN_out_maxr(t)
     minr_out = LIS_DA_struc(n)%ANN_out_minr(t)
     wi(:,:) = LIS_DA_struc(n)%ANN_wi(t,:,:)     
     wo(:) = LIS_DA_struc(n)%ANN_wo(t,:)     

     if(LIS_DA_struc(n)%ANN_activ_function.eq.&
          "Continuous Tan-Sigmoid") then 
        hval = tanh(matmul(transpose(wi),inputs_tp))
        hval(LIS_DA_struc(n)%nhsize) = 1
        outpredl = sum(wo*hval)
        out_value = (outpredl/2.0 + 0.5) * & 
             (maxr_out-minr_out) + minr_out
     endif
     TRACE_EXIT("DA_fwdEst")

   end subroutine LIS_forwardEstimate_with_ANN


!BOP
! !ROUTINE: scaleANNinputs
!  \label{scaleANNinputs}
! 
! !INTERFACE: 
   subroutine scaleANNinputs(n,t,inputs_tp)
! !ARGUMENTS: 
     integer,           intent(in) :: n 
     integer,           intent(in) :: t
     real                          :: inputs_tp(LIS_DA_struc(n)%nppb)
! 
! !DESCRIPTION: 
!  
!   This routine scales the inputs based on their given maximum and
!   minimum values. The max and min values are read from the processed
!   LDT file. 
! 
!  The arguments are: 
!  \begin{description}
!  \item[n]             index of the nest
!  \item[t]             grid space index of the current grid cell
!  \item[inputs\_tp]    array of inputs to be rescaled
! \end{description}
!EOP
     integer                       :: p

     inputs_tp(LIS_DA_struc(n)%nppb) = 1

     do p=1,LIS_DA_struc(n)%nppb - 1
        if((LIS_DA_struc(n)%ANN_inp_maxr(t,p)-&
             LIS_DA_struc(n)%ANN_inp_minr(t,p)).ne.0) then 
           inputs_tp(p) = ((inputs_tp(p) - LIS_DA_struc(n)%ANN_inp_minr(t,p))/&
                (LIS_DA_struc(n)%ANN_inp_maxr(t,p)-&
                LIS_DA_struc(n)%ANN_inp_minr(t,p)) - 0.5)*2
        endif
     enddo
   end subroutine scaleANNinputs

end module LIS_dataAssimMod
