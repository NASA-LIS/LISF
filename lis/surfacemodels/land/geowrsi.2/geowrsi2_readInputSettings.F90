!-----------------------BEGIN NOTICE -- DO NOT EDIT-----------------------
! NASA Goddard Space Flight Center
! Land Information System Framework (LISF)
! Version 7.5
!
! Copyright (c) 2024 United States Government as represented by the
! Administrator of the National Aeronautics and Space Administration.
! All Rights Reserved.
!-------------------------END NOTICE -- DO NOT EDIT-----------------------
!BOP
!
! !ROUTINE: geowrsi2_readInputSettings
!  \label{geowrsi2_readInputSettings}
!
! !REVISION HISTORY:
!
!  23 Jan 2013: KR Arsenault;  Added new user-input parameter file
!  25 Oct 2013: KR Arsenault;  Added GeoWRSI2.0 model to LIS-7
!
! !INTERFACE:
subroutine geowrsi2_readInputSettings()

! !USES:
  use ESMF 
  use LIS_coreMod,   only : LIS_rc, LIS_domain, LIS_localPet
  use LIS_logMod,    only : LIS_logunit, LIS_verify, LIS_endrun
  use LIS_fileIOMod, only : LIS_read_param
  use geowrsi2_module
  use geowrsi2_lsmMod
  use geowrsi2_physics_module, only : offsetTStepByNumTSteps, stepnFromTStep, &
           gTStepsBeforeSeasonStarts, gTStepsAfterSeasonEnds, gTimeStepsPerYear, &
           DifferenceOf2TSteps
  use geowrsi2_arraymgmt_module, only: nullify_ptr, alloc_arr, dealloc_arr
  use fbil_module

!
! !DESCRIPTION:
!  This subroutine is designed to read in GeoWRSI-based user
!  settings input file.
!    
!  The GeoWRSI-based user settings file can be generated by initializing
!   GeoWRSI, or set up independently by the user based on the input file
!   example provided in the WRSI LSM test case.
!
!EOP
  implicit none

  type(ESMF_Config), save :: userinput_config
  type(ESMF_Config), save :: cropinput_config

  integer   :: i, n, t, rc
  logical   :: file_exists
  logical   :: fileread_ok
  logical   :: real4ptr2dIsNull
  type(geowrsi2dec), pointer :: geowrsi2Pt
  real*4, pointer, dimension(:,:) :: real4ptr2d

  logical, allocatable, dimension(:), target :: mask_default
  logical,     pointer, dimension(:)         :: mask

  integer*4 :: SOS
  integer*4 :: SOS_offset
  integer*4 :: lastSOScalcOfSeason_offset
  integer   :: year_temp, ts_temp, offset_temp

  integer*4 :: nTsteps

! _________________________________________________________________________

   write(LIS_logunit,*) "Reading in (Geo-)WRSI Input Settings from File"

   do n = 1, LIS_rc%nnest

      if( LIS_rc%npatch(n,LIS_rc%lsm_index) == 0 ) then
        write(LIS_logunit,'(a30,i5,a6)' ) " MSG: THE PROCESSING ELEMENT,",LIS_localPet,", HAS"
        write(LIS_logunit,'(a45,i2,a15)') &
              "   ZERO-LAND TILES WITHIN DOMAIN FOR NEST,",n,". SKIPPING ..."
        cycle
     endif

!- Setup BIL Geographic Coordination information (from header files):
!  Allocate (internal I/O lib code) keeper of the model grid information
      allocate(gCoords)

    ! Set the grid space
      call geowrsi2_set_gcoords(n)
      call calcXyBounds( &
                      addOffset_arg=(0 +1),     &
                      ifMidPointRoundUp=.true., &
                      minLon=gCoords%minLon,    &
                      ulxmap=gCoords%minLon,    &
                      xdim=gCoords%pixLon,      &
                      maxLon=gCoords%maxLon,    &
                      ulymap=gCoords%maxLat,    &
                      minLat=gCoords%minLat,    &
                      ydim=gCoords%pixLat,      &
                      maxLat=gCoords%maxLat,    &
                      minX=gCoords%minX,        &
                      maxX=gCoords%maxX,        &
                      minY=gCoords%minY,        &
                      maxY=gCoords%maxY         )

    ! Allocate temporary memory for staging the data in:
      call nullify_ptr(real4ptr2dIsNull, real4ptr2d=real4ptr2d)
      real4ptr2dIsNull = alloc_arr(real4ptr2dIsNull, &
                                   dim1Sz=((gCoords%maxX-gCoords%minX) + 1), &
                                   dim2Sz=((gCoords%maxY-gCoords%minY) + 1), &
                                   real4ptr2d=real4ptr2d)

      deallocate(gCoords)

! ----------------------------------------------------------------------

!- Load User-settings input file (filepath read-in from lis.config file)
   inquire(file=trim(geowrsi2_struc(n)%inputParmFile%str), exist=file_exists)
   if( .not. file_exists ) then
      write(LIS_logunit,*) "ERR MSG: WRSI user input parameter file ",&
                           trim(geowrsi2_struc(n)%inputParmFile%str), &
                           " does not exist."
      call LIS_endrun
   endif
   userinput_config = ESMF_ConfigCreate(rc=rc)
   call ESMF_ConfigLoadFile(userinput_config, &
                   trim(geowrsi2_struc(n)%inputParmFile%str), rc=rc)


!== Load CROP input file (filepath read-in from lis.config file)
   call ESMF_ConfigGetAttribute(userinput_config,CropType,label="CropType ",rc=rc)
   call LIS_verify(rc,"CropType: not specified in the user input file")

   inquire( file=trim(geowrsi2_struc(n)%cropDir%str)//"/"//trim(CropType)//".crop",&
            exist=file_exists )
   if( .not. file_exists ) then
      write(LIS_logunit,*) "ERR MSG: WRSI Crop input parameter file ",   &
                trim(geowrsi2_struc(n)%cropDir%str)//"/"//trim(CropType)//".crop", &
                " does not exist."
      call LIS_endrun
   endif

   cropinput_config = ESMF_ConfigCreate(rc=rc)
   call ESMF_ConfigLoadFile(cropinput_config, &
             trim(geowrsi2_struc(n)%cropDir%str)//"/"//trim(CropType)//".crop", rc=rc)

   write(LIS_logunit,*) " WRSI-Inputs: Reading in crop input parameter file: ",   &
                trim(geowrsi2_struc(n)%cropDir%str)//"/"//trim(CropType)//".crop"

!== Read-in inputs: ==

!== INPUTS FROM CROP PARAMETER FILES ...

  ! F1: Fraction at the start of the Vegetative Stage:
    geowrsi2_struc(n)%wrsi%Crop_F1 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_F1', rc=rc)
    call LIS_verify(rc,"crop_F1: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_F1, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_F1 = crop_F1

  ! F2: Fraction at the start of the Flowering Stage:
    geowrsi2_struc(n)%wrsi%Crop_F2 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_F2', rc=rc)
    call LIS_verify(rc,"crop_F2: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_F2, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_F2 = crop_F2

  ! F3: Fraction at the start of the Ripening Stage:
    geowrsi2_struc(n)%wrsi%Crop_F3 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_F3', rc=rc)
    call LIS_verify(rc,"crop_F3: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_F3, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_F3 = crop_F3

  ! K1 or kc_ini: Crop coeff at Initial Stage:
    geowrsi2_struc(n)%wrsi%Crop_K1 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_K1', rc=rc)
    call LIS_verify(rc,"crop_K1: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_K1, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_K1 = crop_K1

  ! K2 or kc_mid: Crop coeff at the Flowering Stage:
    geowrsi2_struc(n)%wrsi%Crop_K2 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_K2', rc=rc)
    call LIS_verify(rc,"crop_K2: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_K2, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_K2 = crop_K2

  ! K3 or kc_end: Crop coeff at the end of the Ripening Stage:
    geowrsi2_struc(n)%wrsi%Crop_K3 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_K3', rc=rc)
    call LIS_verify(rc,"crop_K3: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_K3, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_K3 = crop_K3

  ! Crop_r: Maximum Root Zone for the crop:
    geowrsi2_struc(n)%wrsi%Crop_r = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_r', rc=rc)
    call LIS_verify(rc,"crop_r: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_r, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_r = crop_r

  ! Crop_rini: Initial Root Depth:
    geowrsi2_struc(n)%wrsi%Crop_rini = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_rini', rc=rc)
    call LIS_verify(rc,"crop_rini: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_rini, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_rini = crop_rini

  ! Crop_kp: Max allowable depletion of soil:
    geowrsi2_struc(n)%wrsi%Crop_kp = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_kp', rc=rc)
    call LIS_verify(rc,"crop_kp: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_kp, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_kp = crop_kp

  ! Crop_c1: Coeff for calculating actual ET:
    geowrsi2_struc(n)%wrsi%Crop_c1 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_c1', rc=rc)
    call LIS_verify(rc,"crop_c1: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_c1, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_c1 = crop_c1

  ! Crop_c2: Coeff for calculating actual ET:
    geowrsi2_struc(n)%wrsi%Crop_c2 = LIS_rc%udef
    call ESMF_ConfigFindLabel(cropinput_config, 'crop_c2', rc=rc)
    call LIS_verify(rc,"crop_c2: not specified in the crop input file")
    call ESMF_ConfigNextLine(cropinput_config, rc=rc)
    call ESMF_ConfigGetAttribute(cropinput_config, crop_c2, rc=rc)
    geowrsi2_struc(n)%wrsi%Crop_c2 = crop_c2

    geowrsi2_struc(n)%wrsi%PreSeason_Kc = 0.15
 ! **Note: This value is hard-wired in the GeoWRSI at the time B. Wind implemented
 !     the WRSI code in to LIS.  Eventually this quantity may likely be 
 !     found in the crop parameter files.

!== End READING FROM CROP INPUT FILES ...


!== Begin Reading in CONSTANT INTEGER OR LOGICAL FLAG OPTIONS ==

   write(LIS_logunit,*) " WRSI-Inputs: From GeoWRSI_UserSettings File ... "

!- Enable Permanent Wilting Option:
   geowrsi2_struc(n)%wrsi%PW_EnablePermanentWilting = .false.
   call ESMF_ConfigGetAttribute(userinput_config,EnablePermanentWilting,&
             label="EnablePermanentWilting ",rc=rc)
   call LIS_verify(rc,"EnablePermanentWilting: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%PW_EnablePermanentWilting = EnablePermanentWilting
   write(LIS_logunit,'(A60,1X,L3)')&
        " EnablePermanentWilting =",EnablePermanentWilting

!- Enable Permanent Wilting is activated from SWI values:
   geowrsi2_struc(n)%wrsi%PermanentWiltingIsFromSWI = .false.
   call ESMF_ConfigGetAttribute(userinput_config,PermanentWiltingIsFromSWI,&
             label="PermanentWiltingIsFromSWI ",rc=rc)
   call LIS_verify(rc,"PermanentWiltingIsFromSWI: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%PermanentWiltingIsFromSWI = PermanentWiltingIsFromSWI
   write(LIS_logunit,'(A60,1X,L3)')&
        " PermanentWiltingIsFromSWI =",PermanentWiltingIsFromSWI

!- Enable Permanent Wilting is activated from WRSI values:
   geowrsi2_struc(n)%wrsi%PermanentWiltingIsFromWRSI = .false.
   call ESMF_ConfigGetAttribute(userinput_config,PermanentWiltingIsFromWRSI,&
             label="PermanentWiltingIsFromWRSI ",rc=rc)
   call LIS_verify(rc,"PermanentWiltingIsFromWRSI: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%PermanentWiltingIsFromWRSI = PermanentWiltingIsFromWRSI
   write(LIS_logunit,'(A60,1X,L3)')&
        " PermanentWiltingIsFromWRSI =",PermanentWiltingIsFromWRSI

!- PermanentWilting: Threshold value (in ?):
   geowrsi2_struc(n)%wrsi%PermanentWiltingThresholdValue = LIS_rc%udef   ! 5
   call ESMF_ConfigGetAttribute(userinput_config,PWThresholdValue,&
             label="ThresholdValue ",rc=rc)
   call LIS_verify(rc,"PW ThresholdValue: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%PermanentWiltingThresholdValue = PWThresholdValue
   write(LIS_logunit,'(A60,1X,I3)')&
        " PWThresholdValue =",PWThresholdValue

!- SOS Offset (Dekads)-- Add/subtract a specified number of dekads
!                            to/from the SOS at each pixel:
   geowrsi2_struc(n)%wrsi%SOS_offset = LIS_rc%udef    ! Init as 0 dekads
   call ESMF_ConfigGetAttribute(userinput_config,SOSoffset,label="SOSoffset ",rc=rc)
   call LIS_verify(rc,"SOSoffset: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOS_offset = SOSoffset
   write(LIS_logunit,'(A60,1X,I3)') " SOSoffset =",SOSoffset

!- SOScalc: Calculate Start-of-Season (option) given on user-input criteria:
!  -- If you use the lis.config read-in option ...
!   geowrsi2_struc(n)%wrsi%SOS_CALCULATE = geowrsi2_CalcSOSlsmRunMode
!  -- If you use Brad Wind's original default logical parameter value ...
   geowrsi2_struc(n)%wrsi%SOS_CALCULATE = .true.
   write(LIS_logunit,'(A60,1X,L3)') " SOS_CALCULATE =",.true.

!- SOScalc: Use Rain Threshold to estimate Start-of-Season (option):
   geowrsi2_struc(n)%wrsi%SOScalcUseRainThreshold = .false.
   call ESMF_ConfigGetAttribute(userinput_config,calcsUseRainThreshold,&
             label="calcsUseRainThreshold ",rc=rc)
   call LIS_verify(rc,"SOScalcsUseRainThreshold: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcUseRainThreshold = calcsUseRainThreshold
   write(LIS_logunit,'(A60,1X,L3)')&
         " calcsUseRainThreshold =",calcsUseRainThreshold

!- SOSCalcs: Dekad1 Rainfall Threshold (in mm):
   geowrsi2_struc(n)%wrsi%SOScalcTStep1Threshold = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,Dekad1Threshold,&
             label="Dekad1Threshold ",rc=rc)
   call LIS_verify(rc,"Dekad1Threshold: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcTStep1Threshold = Dekad1Threshold    ! 25mm
   write(LIS_logunit,'(A60,1X,I3)')&
         " Dekad1Threshold =",Dekad1Threshold

!- SOSCalcs: Dekad2+3 Rainfall Threshold (in mm):
   geowrsi2_struc(n)%wrsi%SOScalcTStep2Plus3Threshold = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,Dekad2plus3Threshold,&   ! 20mm
             label="Dekad2plus3Threshold ",rc=rc)
   call LIS_verify(rc,"Dekad2plus3Threshold: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcTStep2Plus3Threshold = Dekad2plus3Threshold
   write(LIS_logunit,'(A60,1X,I3)')&
         " Dekad2plus3Threshold =",Dekad2plus3Threshold

!- SOSCalcs: USE Soil Water Index Threshold:
   geowrsi2_struc(n)%wrsi%SOScalcUseSWIThreshold = .false.
   call ESMF_ConfigGetAttribute(userinput_config,calcsUseSWIthreshold,&   ! False
             label="calcsUseSWIthreshold ",rc=rc)
   call LIS_verify(rc,"SOScalcsUseSWIthreshold: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcUseSWIThreshold = calcsUseSWIthreshold
   write(LIS_logunit,'(A60,1X,L3)')&
         " calcsUseSWIthreshold =",calcsUseSWIthreshold

!- SOSCalcs:  Soil Moisture Threshold (in %):
   geowrsi2_struc(n)%wrsi%SOScalcSoilMoistureThreshold = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,SoilMoistureThreshold,&
             label="SoilMoistureThreshold ",rc=rc)
   call LIS_verify(rc,"SoilMoistureThreshold: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcSoilMoistureThreshold = SoilMoistureThreshold  ! 10%
   write(LIS_logunit,'(A60,1X,I3)')&
         " SoilMoistureThreshold =",SoilMoistureThreshold

!- SOScalc: Use Nearest To Desired Practical Planting Timestep or dekad:
   geowrsi2_struc(n)%wrsi%SOScalcUseNearestToDesiredPracticalPlantingTStep = .false.
   call ESMF_ConfigGetAttribute(userinput_config,UseNearestToDesiredPracticalPlantingDekad,&
             label="UseNearestToDesiredPracticalPlantingDekad ",rc=rc)
   call LIS_verify(rc,&
        "SOScalc:UseNearestToDesiredPracticalPlantingDekad: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcUseNearestToDesiredPracticalPlantingTStep = &
                             UseNearestToDesiredPracticalPlantingDekad
   write(LIS_logunit,'(A60,1X,L3)')&
         " UseNearestToDesiredPracticalPlantingDekad =",&
                        UseNearestToDesiredPracticalPlantingDekad

!- SOSCalcs: Desired planting timestep (in dekads):
   geowrsi2_struc(n)%wrsi%SOScalcDesiredPlantingTStep = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,DesiredPlantingDekad,&   !  0 dekad
             label="DesiredPlantingDekad ",rc=rc)
   call LIS_verify(rc,"SOScalc:DesiredPlantingDekad: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcDesiredPlantingTStep = DesiredPlantingDekad
   write(LIS_logunit,'(A60,1X,I3)')&
         " DesiredPlantingDekad =",DesiredPlantingDekad

!- SOScalc: Use WRSI Threshold Instead of SWI Threshold To Restart:
   geowrsi2_struc(n)%wrsi%SOScalcUseWRSIThresholdInsteadofSWIThresholdToRestart = .false.
   call ESMF_ConfigGetAttribute(userinput_config,&
              useWRSIthresholdInsteadofSWIthresholdToRestart,&
             label="useWRSIthresholdInsteadofSWIthresholdToRestart ",rc=rc)    ! True
   call LIS_verify(rc,&
        "SOScalc:useWRSIthresholdInsteadofSWIthresholdToRestart: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcUseWRSIThresholdInsteadofSWIThresholdToRestart = &
                             useWRSIthresholdInsteadofSWIthresholdToRestart
   write(LIS_logunit,'(A60,1X,L3)')&
         " useWRSIthresholdInsteadofSWIthresholdToRestart =",&
                        useWRSIthresholdInsteadofSWIthresholdToRestart 

!- SOSCalcs: Restart with WRSI Threshold (in %):
   geowrsi2_struc(n)%wrsi%SOScalcRestartThresholdWithWRSI = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,restartThresholdWithWRSI,&   ! 30%
             label="restartThresholdWithWRSI ",rc=rc)
   call LIS_verify(rc,"SOSrestartThresholdWithWRSI: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcRestartThresholdWithWRSI = restartThresholdWithWRSI
   write(LIS_logunit,'(A60,1X,I3)')&
         " restartThresholdWithWRSI =",restartThresholdWithWRSI

!- SOSCalcs: Restart with Soil Water Index Threshold (in %):
   geowrsi2_struc(n)%wrsi%SOScalcRestartThresholdWithSWI = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,restartThresholdWithSWI,&   ! 10%
             label="restartThresholdWithSWI ",rc=rc)
   call LIS_verify(rc,"SOScalc:restartThresholdWithSWI: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcRestartThresholdWithSWI = restartThresholdWithSWI
   write(LIS_logunit,'(A60,1X,I3)')&
         " restartThresholdWithSWI =",restartThresholdWithSWI

!- SOSCalcs: Restart Crop After it has failed:
   geowrsi2_struc(n)%wrsi%SOScalcRestartCropWhenFailed = .false.
   call ESMF_ConfigGetAttribute(userinput_config,RestartCropWhenFailed,&   ! False
             label="RestartCropWhenFailed ",rc=rc)
   call LIS_verify(rc,"SOScalc:RestartCropWhenFailed: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcRestartCropWhenFailed = RestartCropWhenFailed
   write(LIS_logunit,'(A60,1X,L3)')&
         " RestartCropWhenFailed =",RestartCropWhenFailed

!- SOSCalcs: Crop can still restart within percent LGP threshold (%):
   geowrsi2_struc(n)%wrsi%SOScalcCropCanStillRestartWithinPctLGPThreshold = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,CropCanStillRestartWithinPctLGPthreshold,&   ! 40%
             label="CropCanStillRestartWithinPctLGPthreshold ",rc=rc)
   call LIS_verify(rc,"SOScalc:CropCanStillRestartWithinPctLGPthreshold: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcCropCanStillRestartWithinPctLGPThreshold = &
                             CropCanStillRestartWithinPctLGPthreshold
   write(LIS_logunit,'(A60,1X,I3)')&
         " CropCanStillRestartWithinPctLGPthreshold =",&
                        CropCanStillRestartWithinPctLGPthreshold

!- SOSCalcs: Ignore SOS Climatology option:
   geowrsi2_struc(n)%wrsi%SOScalcIgnoreClimatology = .false.
   call ESMF_ConfigGetAttribute(userinput_config,IgnoreClimatology,&   ! False
             label="IgnoreClimatology ",rc=rc)
   call LIS_verify(rc,"SOScalc:IgnoreClimatology: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcIgnoreClimatology = IgnoreClimatology
   write(LIS_logunit,'(A60,1X,L3)')&
         " IgnoreClimatology =",IgnoreClimatology

!- SOS Climatology parameters: used for constraining SOS calculation ...
!- SOSCalcs: Max Dekads (TSteps) Early (in dekads):
   geowrsi2_struc(n)%wrsi%SOScalcMaxTStepsEarly = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,maxDeksEarly,&   ! 2 dekads
             label="maxDeksEarly ",rc=rc)
   call LIS_verify(rc,"SOScalc:maxDeksEarly: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcMaxTStepsEarly = maxDeksEarly
   write(LIS_logunit,'(A60,1X,I3)') " maxDeksEarly =",maxDeksEarly

!- SOSCalcs: Max Dekads (TSteps) Late (in dekads):
   geowrsi2_struc(n)%wrsi%SOScalcMaxTStepsLate = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,maxDeksLate,&   ! 9 dekads
             label="maxDeksLate ",rc=rc)
   call LIS_verify(rc,"SOScalc:maxDeksLate: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcMaxTStepsLate = maxDeksLate
   write(LIS_logunit,'(A60,1X,I3)') " maxDeksLate =",maxDeksLate
! ................

!- SOSCalcs: Exclude incomplete areas from SOS calculation (option):
   geowrsi2_struc(n)%wrsi%SOScalcExcludeIncompleteAreasFromSOS = .false.
   call ESMF_ConfigGetAttribute(userinput_config,ExcludeIncompleteAreasFromSOS,&   ! True
             label="ExcludeIncompleteAreasFromSOS ",rc=rc)
   call LIS_verify(rc,"SOScalc:ExcludeIncompleteAreasFromSOS: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcExcludeIncompleteAreasFromSOS = ExcludeIncompleteAreasFromSOS
   write(LIS_logunit,'(A60,1X,L3)') &
            " ExcludeIncompleteAreasFromSOS =",ExcludeIncompleteAreasFromSOS

!- SOSCalcs: Acceptable Percentage of Total Seasonal Growth (%):
   geowrsi2_struc(n)%wrsi%SOScalcAcceptablePercentOfTotalSeasonalGrowth = LIS_rc%udef
   call ESMF_ConfigGetAttribute(userinput_config,AcceptablePercentOfTotalSeasonalGrowth,&   ! 90%
             label="AcceptablePercentOfTotalSeasonalGrowth ",rc=rc)
   call LIS_verify(rc,"SOScalc:AcceptablePercentOfTotalSeasonalGrowth: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%SOScalcAcceptablePercentOfTotalSeasonalGrowth = &
                             AcceptablePercentOfTotalSeasonalGrowth
   write(LIS_logunit,'(A60,1X,I3)') &
           " AcceptablePercentOfTotalSeasonalGrowth =",AcceptablePercentOfTotalSeasonalGrowth

!- Photo sensitivity (option) -- ??PermanentWiltingIsFromPlantPhysiology??:
   geowrsi2_struc(n)%wrsi%Photosensitive = .false.

!- PermanentWiltingIsFromPlantPhysiology:
!   call ESMF_ConfigGetAttribute(userinput_config,PermanentWiltingIsFromPlantPhysiology,&   ! False
!             label="PermanentWiltingIsFromPlantPhysiology ",rc=rc)
!   call LIS_verify(rc,"PermanentWiltingIsFromPlantPhysiology: not specified in the user input file")
!   geowrsi2_struc(n)%wrsi%Photosensitive = PermanentWiltingIsFromPlantPhysiology

!- 49) Run regardless of sufficient data (based on original GeoWRSI VB code):
    geowrsi2_struc(n)%wrsi%RunRegardlessOfSufficientData = .false.     ! False
!   -- Used to determine if sufficient precipitation data are available to see
!       if the SOS can be calculated.

!- "LastCurrent" Files (originally set for FEWSNET Supp Forcing but still used in LSM code)
!  LastCurrentYear is the end year of the run;
!   print *, "LastCurrentYear              : ", geowrsi2_struc(n)%LastCurrentYear

! --- IGNORED HERE ---
! -- Simulation Timestep Parameters (found in GeoWRSI UserSettingsInput file)
!  == Not included in the LIS-WRSI version, since these options are truly only 
!  == valid in the VB GeoWRSI version, which can run dekad at a time based on
!  == user-input.  LIS-WRSI runs the entire growing season at one time, and then
!  == the user has the option to look at which ever dekad output afterwards.
! --- IGNORED HERE ---

!== End CONSTANT INTEGER OR LOGICAL FLAG OPTIONS ==

!== Mask Default (Set to true):
    allocate(mask_default(LIS_rc%npatch(n,LIS_rc%lsm_index)))
    mask_default = .true.
    mask => mask_default


! === BEGIN TIME-BASED VARIABLES  ===

!- Initialize growing season parameter:
   geowrsi2_struc(n)%wrsi%growing_season = 1

!== Initial Year of WRSI run: 
!- Input can be obtained from the GeoWRSI UserInputSettings file:
!   geowrsi2_struc(n)%wrsi%InitialYear = int(LIS_rc%udef)
!   call ESMF_ConfigGetAttribute(userinput_config,InitialYear,label="InitialYear ",rc=rc)
!   call LIS_verify(rc,"InitialYear: not specified in the user input file")
   geowrsi2_struc(n)%wrsi%InitialYear = geowrsi2_struc(n)%InitialYear
   write(LIS_logunit,'(A60,1X,I4)') " InitialYear =",geowrsi2_struc(n)%InitialYear

!== Initial and final crop growing season timestep of WRSI run:
!   (originally from Regional input file but read in from lis.config for now)
   geowrsi2_struc(n)%wrsi%InitialTStep = geowrsi2_struc(n)%initTstepSeason   ! initialDekad   
   geowrsi2_struc(n)%wrsi%FinalTStep   = geowrsi2_struc(n)%finalTstepSeason  ! finalDekad   
   write(LIS_logunit,'(A60,1X,I3)') " initialDekad =",geowrsi2_struc(n)%initTstepSeason
   write(LIS_logunit,'(A60,1X,I3)') " finalDekad =",geowrsi2_struc(n)%finalTStepSeason

!== Physics_activation_terms (physics_activation_yr and physics_activation_ts):

!- Initialize physics_activation year and timestep:
   year_temp = 0; ts_temp = 0

   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      if(mask(t) .eqv. .true.) then
         geowrsi2Pt => geowrsi2_struc(n)%wrsi(t)

         geowrsi2Pt%physics_activation_yr = geowrsi2Pt%InitialYear
         geowrsi2Pt%physics_activation_ts = geowrsi2Pt%InitialTStep

         call offsetTStepByNumTSteps( geowrsi2Pt%physics_activation_ts, &
                                     (0 - gTStepsBeforeSeasonStarts),   &
                                      geowrsi2Pt%physics_activation_yr )
         year_temp = geowrsi2Pt%physics_activation_yr
         ts_temp   = geowrsi2Pt%physics_activation_ts
      endif
   end do
   if( year_temp /= 0 .and. ts_temp /= 0 ) then 
      write(LIS_logunit,'(A60,1X,I4)') " Physics Activation Year =",year_temp
      write(LIS_logunit,'(A60,1X,I3)') " Physics Activation Tstep =",ts_temp
   endif

!== FinalYear: (FinalYearFromDataFile)
 ! The following FinalYear calc required values: InitialYear, InitialTStep, FinalTSTep
   year_temp = 0
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      if(mask(t) .eqv. .true.) then
         geowrsi2Pt => geowrsi2_struc(n)%wrsi(t)
         geowrsi2Pt%FinalYearFromDataFile = geowrsi2Pt%InitialYear

         if( geowrsi2Pt%InitialTStep > geowrsi2Pt%FinalTStep ) then
            geowrsi2Pt%FinalYearFromDataFile = geowrsi2Pt%FinalYearFromDataFile + 1
         endif
         year_temp = geowrsi2Pt%FinalYearFromDataFile
      end if
   end do
   if( year_temp /= 0 ) then
      write(LIS_logunit,'(A60,1X,I4)') " FinalYearFromDataFile =",year_temp
   endif

!== LastSOScalcofSeason Inputs: lastSOScalcOfSeasonYr, lastSOScalcOfSeasonTStep

 ! The following lastSOScalcOfSeason year and timestep calculations require: 
 !   InitialYear, InitialTStep, FinalTSTep, FinalYearFromDataFile
 !
 ! Note:  Except for disallowing this last calculated date to overlap with the
 !   start date of the next season (which was done to support multi-season runs),
 !   this is how the original GeoWRSI model calculated end of season for SOScalc
 !   purposes (i.e. by using the final yr+ts data read from file). It could be
 !   circular reasoning to utilize FinalYear and FinalTStep (as opposed to
 !   FinalYearFromDataFile and FinalTStep) to calculate lastSOScalcOfSeason yr and ts
 !   because SOS is used to compute FinalYear and FinalTStep!!

   year_temp = 0; ts_temp = 0; offset_temp = 0
!   t = 1
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      if(mask(t) .eqv. .true.) then
       geowrsi2Pt => geowrsi2_struc(n)%wrsi(t)
       geowrsi2_struc(n)%lastSOScalcOfSeasonYr    = geowrsi2Pt%InitialYear
       geowrsi2_struc(n)%lastSOScalcOfSeasonTStep = geowrsi2Pt%InitialTStep

       lastSOScalcOfSeason_offset = stepnFromTStep( &
                 int(geowrsi2Pt%FinalYearFromDataFile, 4), &
                 geowrsi2Pt%FinalTStep,            &
                 int(geowrsi2Pt%InitialYear, 4),   &
                 geowrsi2Pt%InitialTStep,          &
                 gTStepsAfterSeasonEnds )

       call offsetTStepByNumTSteps( geowrsi2_struc(n)%lastSOScalcOfSeasonTStep, &
                                   lastSOScalcOfSeason_offset, &
                                   geowrsi2_struc(n)%lastSOScalcOfSeasonYr )

       offset_temp = lastSOScalcOfSeason_offset
       year_temp = geowrsi2_struc(n)%lastSOScalcOfSeasonYr 
       ts_temp   = geowrsi2_struc(n)%lastSOScalcOfSeasonTStep
       exit    ! exit after filling
      end if   ! End mask check
   end do
   if( year_temp /= 0 .and. ts_temp /= 0 ) then
      write(LIS_logunit,'(A60,1X,I3)') " lastSOScalcOfSeason_offset =",offset_temp
      write(LIS_logunit,'(A60,1X,I4)') " lastSOScalcOfSeasonYear =",year_temp
      write(LIS_logunit,'(A60,1X,I3)') " lastSOScalcOfSeasonTStep =",ts_temp
   endif

! ----------------------------------------------------------------------------------

!== Begin 2D PARAMETER FILES ==

!== WRSI Regional Land Mask: 
   call LIS_read_param(n,"WRSIMASK",real4ptr2d)
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      geowrsi2_struc(n)%wrsi(t)%Mask = &
         int(real4ptr2d(LIS_domain(n)%tile(t)%col,LIS_domain(n)%tile(t)%row))
   end do

!== Length of Growing Period (LGP) Timesteps (Dekads): 
   call LIS_read_param(n,"LGP",real4ptr2d)
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      geowrsi2_struc(n)%wrsi(t)%LGP_TIMESTEPS = &
         int(real4ptr2d(LIS_domain(n)%tile(t)%col,LIS_domain(n)%tile(t)%row))
   end do
! ** NOTE:  LPGnumdekads is different from the 2-d dist. field read in ...

!== Water holding capacity (WHC; mm units): 
   call LIS_read_param(n,"WHC",real4ptr2d)
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      geowrsi2_struc(n)%wrsi(t)%WHC = &
         int(real4ptr2d(LIS_domain(n)%tile(t)%col,LIS_domain(n)%tile(t)%row))
   end do

!== WRSI Climatology file (distributed): 
   call LIS_read_param(n,"WRSICLIM",real4ptr2d)
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      geowrsi2_struc(n)%wrsi(t)%WRSIClim = &
         int(real4ptr2d(LIS_domain(n)%tile(t)%col,LIS_domain(n)%tile(t)%row))
   end do

!== SOS Climatology file (distributed): 
   call LIS_read_param(n,"SOSCLIM",real4ptr2d)
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      geowrsi2_struc(n)%wrsi(t)%SOSClimFromDataFile = &
         int(real4ptr2d(LIS_domain(n)%tile(t)%col,LIS_domain(n)%tile(t)%row))
   end do

!- Initialize SOS Climatology field:
   geowrsi2_struc(n)%wrsi%SOSClim = LIS_rc%udef

! =======================================================================

 ! The following SOSClim conditional assignment requires values:
 !  => SOS_CALCULATE, SOScalcIgnoreClimatology
   do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
      if(mask(t) .eqv. .true.) then
         geowrsi2Pt => geowrsi2_struc(n)%wrsi(t)
       ! Same as GeoWRSI initialization (i.e.  set to '0')
         geowrsi2Pt%SOSClim = 0
         if( (geowrsi2Pt%SOS_CALCULATE .eqv. .false.)      .or. &
             (geowrsi2Pt%SOScalcIgnoreClimatology .eqv. .true.) &
           ) cycle
         geowrsi2Pt%SOSClim = geowrsi2Pt%SOSClimFromDataFile

       ! Assign a "Final Year" term:
         geowrsi2Pt%FinalYear = geowrsi2Pt%InitialYear
         if( geowrsi2Pt%FinalTStep < geowrsi2Pt%InitialTStep ) then
           geowrsi2Pt%FinalYear = geowrsi2Pt%FinalYear + 1
         endif

      endif
   end do

 ! NOTE:  **IF SOS_CALCULATE.EQ.TRUE .AND. SOScalcIgnoreClimatology.EQ.FALSE THEN**
 !
 !  ==> Use the expected fixed parameter quantity (as read from the appropriate 
 !  parameter data file).  SOS_CALCULATE and SOScalcIgnoreClimatology represent, 
 !  as they did in GeoWRSI, user-configurable program option quantities; here in LIS-
 !  WRSI kept at the tile-level.  Hence, the following treatment here in which the
 !  order of these quantities are read is crucial.  Setup in this exact manner
 !  aligns precisely with the way that these program options were created in the
 !  the original model application.

! -------------------------------------------------
!      Read Initial SOS and SOS-Anomaly Files
! -------------------------------------------------

!- Initialize SOS fields:
   geowrsi2_struc(n)%wrsi%SOS  = LIS_rc%udef     ! 0 dekad init
   geowrsi2_struc(n)%wrsi%SOSa = 0               ! 0 set by B. Wind

!- Activate only if WRSI Run-mode ...
   if( geowrsi2_CalcSOSlsmRunMode .neqv. .true. .and. &   ! WRSI-mode
       LIS_rc%nensem(n) == 1 ) then   

     year_temp = geowrsi2_struc(n)%lastSOScalcOfSeasonYr 

     call geowrsi2_readSOS_Bilfile( n, LIS_rc%npatch(n,LIS_rc%lsm_index),&
                   year_temp, geowrsi2_struc(n)%wrsi%SOS, &
                   geowrsi2_struc(n)%wrsi%SOSa, geowrsi2_struc(n)%wrsi%SOS_offset )


  !- Update Final Year and Final TStep based on SOS+LGP timesteps:
     nTsteps = 0.
     do t = 1, LIS_rc%npatch(n,LIS_rc%lsm_index)
        if( mask(t) .eqv. .true. ) then
          geowrsi2Pt => geowrsi2_struc(n)%wrsi(t)
          geowrsi2Pt%FinalYear = geowrsi2Pt%InitialYear 
          if( geowrsi2Pt%FinalTStep < geowrsi2Pt%InitialTStep ) then
            geowrsi2Pt%FinalYear = geowrsi2Pt%FinalYear + 1
          endif
          nTsteps = stepnFromTStep( &
                       int(geowrsi2Pt%FinalYear,4), geowrsi2Pt%FinalTStep, &
                       int(geowrsi2Pt%InitialYear, 4), geowrsi2Pt%InitialTStep, &
                       (gTStepsBeforeSeasonStarts+gTStepsAfterSeasonEnds) ) 

          if( (geowrsi2Pt%SOS == int(LIS_rc%udef))       .or. &
              (geowrsi2Pt%LGP_TIMESTEPS == int(LIS_rc%udef))  &
            ) cycle

          geowrsi2Pt%FinalYear  = geowrsi2Pt%InitialYear
          geowrsi2Pt%FinalTStep = int(LIS_rc%udef)     ! Reinitialize

          if( geowrsi2Pt%SOS < geowrsi2Pt%InitialTStep ) then
             geowrsi2Pt%FinalYear = geowrsi2Pt%FinalYear + 1
          endif

          geowrsi2Pt%FinalTStep = geowrsi2Pt%SOS

          call offsetTStepByNumTSteps(     &
                     geowrsi2Pt%FinalTStep,    & 
                     geowrsi2Pt%LGP_TIMESTEPS, &
                     geowrsi2Pt%FinalYear)     

          if( (geowrsi2Pt%LGP_TIMESTEPS+gTStepsBeforeSeasonStarts) >= nTsteps ) then
             geowrsi2Pt%FinalTStep = geowrsi2Pt%FinalTStep - &
                  ((geowrsi2Pt%LGP_TIMESTEPS+gTStepsBeforeSeasonStarts+1)-nTsteps)

             do while( geowrsi2Pt%FinalTStep <= 0 )
                geowrsi2Pt%FinalTStep = geowrsi2Pt%FinalTStep + gTimeStepsPerYear
                geowrsi2Pt%FinalYear = geowrsi2Pt%FinalYear - 1
             enddo
          endif

        endif
     end do

   endif   ! end WRSI run-mode check

!== End 2D PARAMETER FILES ==

! --------------------------------------------------------

   deallocate(mask_default)
   call dealloc_arr(real4ptr2dIsNull, real4ptr2d=real4ptr2d)
   call nullify_ptr(real4ptr2dIsNull, real4ptr2d=real4ptr2d)

! ========================================================================

  end do ! End nest loop

end subroutine geowrsi2_readInputSettings

